{
   "distribution" : "Mail-Message",
   "project" : "Mail-Message",
   "manuals" : {
      "Mail::Message::Convert::MailInternet" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Convert::MailInternet",
         "title" : "translate Mail::Message to Mail::Internet vv",
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Convert::MailInternet - translate Mail::Message to Mail::Internet vv\n",
               "level" : 1
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " use Mail::Message::Convert::MailInternet;\n my $convert = Mail::Message::Convert::MailInternet->new;\n\n my Mail::Message  $msg    = M<Mail::Message>->new;\n my Mail::Internet $intern = $convert->export($msg);\n\n my Mail::Internet $intern = M<Mail::Internet>->new;\n my Mail::Message  $msg    = $convert->from($intern);\n\n use M<Mail::Box::Manager>;\n my $mgr     = Mail::Box::Manager->new;\n my $folder  = $mgr->open(folder => 'Outbox');\n $folder->addMessage($intern);\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "The M<Mail::Internet> class of messages is very popular for all\nkinds of message applications written in Perl.  However, the\nformat was developed when e-mail messages where still small and\nattachments where rare; Mail::Message is much more flexible in\nthis respect.\n",
               "path" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "type" : "Section",
                     "name" : "Converting",
                     "level" : 2,
                     "path" : "METHODS/Converting"
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "package" : "Mail::Message::Convert::MailInternet",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Convert/MailInternet.pm"
      },
      "Mail::Message::Field::Attribute" : {
         "name" : "Mail::Message::Field::Attribute",
         "title" : "one attribute of a full field",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Field::Attribute - one attribute of a full field\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my $field    = $msg->head->get('Content-Disposition') or return;\n my $full     = $field->study;   # full understanding in unicode\n my $filename = $full->attribute('filename')           or return;\n\n print ref $filename;     # this class name\n print $filename;         # the attributes content in utf-8\n print $filename->value;  # same\n print $filename->string; # print string as was found in the file\n $filename->print(\\*OUT); # print as was found in the file\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "Attributes within MIME fields can be quite complex, and therefore be slow\nand consumes a lot of memory.  The M<Mail::Message::Field::Fast> and\nM<Mail::Message::Field::Flex> simplify them the attributes a lot, which\nmay result in erroneous behavior in rare cases.  With the increase of\nnon-western languages on Internet, the need for the complex headers\nbecomes more and more in demand.\n\nA C<Mail::Message::Field::Attribute> can be found in any structured\nM<Mail::Message::Field::Full> header field.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "nest" : [
                  {
                     "name" : "Constructors",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "path" : "METHODS/The attribute",
                     "type" : "Section",
                     "name" : "The attribute",
                     "level" : 2
                  },
                  {
                     "level" : 2,
                     "name" : "Attribute encoding",
                     "type" : "Section",
                     "path" : "METHODS/Attribute encoding"
                  },
                  {
                     "name" : "Internals",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Internals"
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/Attribute.pm",
         "package" : "Mail::Message::Field::Attribute"
      },
      "Mail::Message::Body::String" : {
         "version" : "3.018",
         "source" : "lib/Mail/Message/Body/String.pm",
         "package" : "Mail::Message::Body::String",
         "name" : "Mail::Message::Body::String",
         "title" : "body of a Mail::Message stored as single string",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Body::String - body of a Mail::Message stored as single string\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " See M<Mail::Message::Body>\n"
            },
            {
               "level" : 1,
               "description" : "The body (content) of a message can be stored in various ways.  In this\ndocumentation you will find the description of extra functionality you have\nwhen a message is stored as a single scalar.  \n\nStoring a whole message in one string is only a smart choice when the content\nis small or encoded. Even when stored as a scalar, you can still treat the\nbody as if the data is stored in lines or an external file, but this will be\nslower.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0
      },
      "Mail::Message::Field::Unstructured" : {
         "package" : "Mail::Message::Field::Unstructured",
         "source" : "lib/Mail/Message/Field/Unstructured.pm",
         "version" : "3.018",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "title" : "smart unstructured field",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Field::Unstructured - smart unstructured field\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "level" : 1,
               "description" : " my $f = Mail::Message::Field::Unstructured->new('Comments', 'hi!');\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "Unstructured fields do contain information which is not restricted in\nany way.  RFC2822 defines some unstructured fields, but by default all\nunknown fields are unstructured as well.  Things like attributes and\ncomments have no meaning for unstructured fields, but encoding does.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Access to the content",
                     "type" : "Section",
                     "name" : "Access to the content",
                     "level" : 2
                  }
               ]
            }
         ],
         "name" : "Mail::Message::Field::Unstructured"
      },
      "Mail::Message::Convert" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Convert",
         "title" : "conversions between message types",
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Convert - conversions between message types\n",
               "level" : 1
            },
            {
               "level" : 1,
               "description" : "Available methods are very converter-specific.\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "nest" : [
                  {
                     "description" : "Internally, the M<Mail::Message::coerce()> is called when foreign objects\nare used where message objects are expected.  That method will automatically\ncreate the converting objects, and re-use them.\n\n\n=over 4\n\n=item * M<Mail::Message::Convert::MailInternet>\nConverts the simple M<Mail::Internet> messages into M<Mail::Message>\nobjects.\n\n\n=item * M<Mail::Message::Convert::MimeEntity>\nConverts the more complicated M<MIME::Entity> messages into\nM<Mail::Message> objects.\n\n\n=item * M<Mail::Message::Convert::EmailSimple>\nConverts M<Email::Simple> messages into M<Mail::Message> objects.\n\n\n=back\n",
                     "level" : 2,
                     "name" : "Converters between message objects",
                     "type" : "Section",
                     "path" : "DESCRIPTION/Converters between message objects"
                  },
                  {
                     "path" : "DESCRIPTION/Other converters",
                     "level" : 2,
                     "description" : "=over 4\n\n\n=item * M<Mail::Message::Convert::Html>\nPlays tricks with HTML/XMHTML without help of external modules.\n\n\n=item * M<Mail::Message::Convert::HtmlFormatText>\nConverts HTML body objects to plain text objects using the\nHTML::FormatText module.\n\n\n=item * M<Mail::Message::Convert::HtmlFormatPS>\nConverts HTML body objects to Postscript objects using the\nM<HTML::FormatPS> module.\n\n\n=item * M<Mail::Message::Convert::TextAutoformat>\nConverts a text message into text using M<Text::Autoformat>.\n\n\n=back\n",
                     "type" : "Section",
                     "name" : "Other converters"
                  }
               ],
               "level" : 1,
               "description" : "This class is the base for various message (and message parts) converters.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Converting",
                     "type" : "Section",
                     "name" : "Converting",
                     "level" : 2
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Error handling",
                     "path" : "METHODS/Error handling"
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "package" : "Mail::Message::Convert",
         "source" : "lib/Mail/Message/Convert.pm",
         "version" : "3.018"
      },
      "Mail::Message::Convert::MimeEntity" : {
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Convert::MimeEntity - translate Mail::Message to MIME::Entity vv\n",
               "level" : 1
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " use Mail::Message::Convert::MimeEntity;\n my $convert = Mail::Message::Convert::MimeEntity->new;\n\n my Mail::Message $msg    = M<Mail::Message>->new;\n my MIME::Entity  $entity = $convert->export($msg);\n\n my MIME::Entity  $entity = M<MIME::Entity>->new;\n my Mail::Message $msg    = $convert->from($entity);\n\n use Mail::Box::Manager;\n my $mgr     = M<Mail::Box::Manager>->new;\n my $folder  = $mgr->open(folder => 'Outbox');\n $folder->addMessage($entity);\n"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "The M<MIME::Entity> extends M<Mail::Internet> message with multiparts\nand more methods.  The M<Mail::Message> objects are more flexible\nin how the message parts are stored, and uses separate header and body\nobjects.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Converting",
                     "name" : "Converting",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "translate Mail::Message to MIME::Entity vv",
         "name" : "Mail::Message::Convert::MimeEntity",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "source" : "lib/Mail/Message/Convert/MimeEntity.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Convert::MimeEntity"
      },
      "Mail::Message::Head" : {
         "chapters" : [
            {
               "path" : "NAME",
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Head - the header of one message\n"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my $head = Mail::Message::Head->new;\n $head->add('From: me@localhost');\n $head->add(From => 'me@localhost');\n $head->add(Mail::Message::Field->new(From => 'me'));\n my $subject = $head->get('subject');\n my @rec = $head->get('received');\n $head->delete('From');\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "C<Mail::Message::Head> MIME headers are part of M<Mail::Message> messages,\nwhich are grouped in M<Mail::Box> folders.\n\nA long list of standard MIME header fields with definitions can be found\nin RFC4021 (F<https://www.rfc-editor.org/rfc/rfc4021.html>) and its\nupdates RFC5322 and RFC6854.\n\nB<ATTENTION!!!> most functionality about e-mail headers is described\nin M<Mail::Message::Head::Complete>, which is a matured header object.\nOther kinds of headers will be translated to that type when time comes.\n\nOn this page, the general methods which are available on any header are\ndescribed.  Read about differences in the sub-class specific pages.\n",
               "level" : 1
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Constructors"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "The header",
                     "path" : "METHODS/The header"
                  },
                  {
                     "path" : "METHODS/Access to the header",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Access to the header"
                  },
                  {
                     "type" : "Section",
                     "name" : "About the body",
                     "level" : 2,
                     "path" : "METHODS/About the body"
                  },
                  {
                     "level" : 2,
                     "name" : "Internals",
                     "type" : "Section",
                     "path" : "METHODS/Internals"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter"
            },
            {
               "type" : "Chapter",
               "name" : "DETAILS",
               "level" : 1,
               "nest" : [
                  {
                     "level" : 2,
                     "description" : "Many Perl implementations make a big mistake by disturbing the order\nof header fields.  For some fields (especially the I<resent groups>,\nsee M<Mail::Message::Head::ResentGroup>) the order shall be\nmaintained.\n\nMailBox will keep the order of the fields as they were found in the\nsource.  When your add a new field, it will be added at the end.  If\nyour replace a field with a new value, it will stay in the original\norder.\n",
                     "type" : "Section",
                     "name" : "Ordered header fields",
                     "path" : "DETAILS/Ordered header fields"
                  },
                  {
                     "level" : 2,
                     "description" : "The header of a MIME message object contains a set of lines, which are\ncalled I<fields> (by default represented by M<Mail::Message::Field>\nobjects).  Dependent on the situation, the knowledge about the fields can\nbe in one of three situations, each represented by a sub-class of this\nmodule:\n\n\n=over 4\n\n\n=item * M<Mail::Message::Head::Complete>\n\nIn this case, it is sure that all knowledge about the header is available.\nWhen you M<get()> information from the header and it is not there, it will\nnever be there.\n\n\n=item * M<Mail::Message::Head::Subset>\n\nThere is no certainty whether all header lines are known (probably not).  This\nmay be caused as result of reading a fast index file, as described in\nM<Mail::Box::MH::Index>.  The object is automatically transformed\ninto a M<Mail::Message::Head::Complete> when all header lines must be known.\n\n\n=item * M<Mail::Message::Head::Partial>\n\nA partial header is like a subset header: probably the header is incomplete.\nThe means that you are not sure whether a M<get()> for a field fails because\nthe field is not a part of the message or that it fails because it is not\nyet known to the program.  Where the subset header knows where to get the\nother fields, the partial header does not know it.  It cannot hide its\nimperfection.\n\n\n=item * M<Mail::Message::Head::Delayed>\n\nIn this case, there is no single field known.  Access to this header will\nalways trigger the loading of the full header.\n\n\n=back\n",
                     "type" : "Section",
                     "name" : "Head class implementation",
                     "path" : "DETAILS/Head class implementation"
                  },
                  {
                     "name" : "Subsets of header fields",
                     "type" : "Section",
                     "description" : "Message headers can be quite large, and therefore MailBox provides\nsimplified access to some subsets of information.  You can grab these\nsets of fields together, create and delete them as group.\n\nOn the moment, the following sets are defined:\n\n\n=over 4\n\n=item * M<Mail::Message::Head::ResentGroup>\nA I<resent group> is a set of fields which is used to log one step\nin the transmission of the message from the original sender to the\ndestination.\n\nEach step adds a set of headers to indicate when the message was received\nand how it was forwarded (without modification).  These fields are\nbest created using M<Mail::Message::bounce()>.\n\n\n=item * M<Mail::Message::Head::ListGroup>\nFields which are used to administer and log mailing list activity.  Mailing\nlist software has to play trics with the original message to be able to\nget the reply on that message back to the mailing list.  Usually a large\nnumber of lines are added.\n\n\n=item * M<Mail::Message::Head::SpamGroup>\nA set of fields which contains header fields which are produced by\nspam detection software.  You may want to remove these fields when\nyou store a message for a longer period of time.\n\n=back\n",
                     "level" : 2,
                     "path" : "DETAILS/Subsets of header fields"
                  }
               ],
               "path" : "DETAILS"
            }
         ],
         "title" : "the header of one message",
         "name" : "Mail::Message::Head",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Head.pm",
         "package" : "Mail::Message::Head"
      },
      "Mail::Message::TransferEnc" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::TransferEnc",
         "title" : "message transfer encoder/decoder",
         "chapters" : [
            {
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::TransferEnc - message transfer encoder/decoder\n",
               "level" : 1,
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(transfer => 'base64');\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "description" : "This class is the base for various encoders and decoders, which are\nused during transport of the message.  These packages, and all which are\nderived, are invoked by the message's M<Mail::Message::decoded()> and\nM<Mail::Message::encode()> methods:\n\n my $message = $folder->message(3);\n my $decoded_body = $message->decoded;\n my $encoded_body = $message->encode(transfer => 'base64');\n\nRules for transfer encodings are specified in RFC4289.  The full list\nof permissible content transfer encodings can be found at\nF<https://www.iana.org/assignments/transfer-encodings/transfer-encodings.xhtml>\n\nThe following coders/decoders are currently supported (April 2025, the full\nlist at IANA):\n\n\n=over 4\n\n\n=item * M<Mail::Message::TransferEnc::Base64>\n\nC<base64> for binary information.\n\n\n=item * M<Mail::Message::TransferEnc::SevenBit>\n\nC<7bit> for plain old ASCII characters only.\n\n\n=item * M<Mail::Message::TransferEnc::EightBit>\n\nC<8bit> for extended character set data, not encoded.\n\n\n=item * M<Mail::Message::TransferEnc::QuotedPrint>\n\nC<quoted-printable> encdoded extended character set data.\n\n\n=back\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/The Encoder",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "The Encoder"
                  },
                  {
                     "path" : "METHODS/Encoding",
                     "type" : "Section",
                     "name" : "Encoding",
                     "level" : 2
                  },
                  {
                     "level" : 2,
                     "name" : "Error handling",
                     "type" : "Section",
                     "path" : "METHODS/Error handling"
                  }
               ]
            }
         ],
         "package" : "Mail::Message::TransferEnc",
         "source" : "lib/Mail/Message/TransferEnc.pm",
         "version" : "3.018"
      },
      "Mail::Message::Convert::TextAutoformat" : {
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Convert::TextAutoformat - Reformat plain text messages\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " use Mail::Message::Convert::TextAutoformat;\n my $af = Mail::Message::Convert::TextAutoformat->new;\n\n my $beautified_body = $af->autoformatBody($body);\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "Play trics with plain text, for instance bodies with type C<text/plain>\nusing Damian Conway's M<Text::Autoformat>.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Converting",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Converting"
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "title" : "Reformat plain text messages",
         "name" : "Mail::Message::Convert::TextAutoformat",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Convert/TextAutoformat.pm",
         "package" : "Mail::Message::Convert::TextAutoformat"
      },
      "Mail::Message::Field::Flex" : {
         "name" : "Mail::Message::Field::Flex",
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Field::Flex - one line of a message header\n",
               "level" : 1
            },
            {
               "path" : "SYNOPSIS",
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "level" : 1
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "This is the flexible implementation of a field: it can easily be\nextended because it stores its data in a hash and the constructor\n(C<new>) and initializer (C<init>) are split.  However, you pay the\nprice in performance.  M<Mail::Message::Field::Fast> is faster (as the\nname predicts).\n",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "title" : "one line of a message header",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/Flex.pm",
         "package" : "Mail::Message::Field::Flex"
      },
      "Mail::Box::Parser::Perl" : {
         "chapters" : [
            {
               "path" : "NAME",
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Box::Parser::Perl - reading messages from file using Perl\n"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "The C<Mail::Box::Parser::Perl> implements parsing of messages\nin Perl.  This may be a little slower than the C<C> based parser\nM<Mail::Box::Parser::C>, but will also work on platforms where no C\ncompiler is available.\n"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Attributes",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Attributes"
                  },
                  {
                     "path" : "METHODS/Parsing",
                     "type" : "Section",
                     "name" : "Parsing",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2,
                     "path" : "METHODS/Error handling"
                  },
                  {
                     "level" : 2,
                     "name" : "Cleanup",
                     "type" : "Section",
                     "path" : "METHODS/Cleanup"
                  }
               ],
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter"
            }
         ],
         "title" : "reading messages from file using Perl",
         "name" : "Mail::Box::Parser::Perl",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "source" : "lib/Mail/Box/Parser/Perl.pm",
         "version" : "3.018",
         "package" : "Mail::Box::Parser::Perl"
      },
      "Mail::Message::Body::Nested" : {
         "source" : "lib/Mail/Message/Body/Nested.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Body::Nested",
         "title" : "body of a message which contains a message",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Body::Nested - body of a message which contains a message\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " See M<Mail::Message::Body>\n\n if($body->isNested) {\n    my $nest = $body->nested;\n    $nest->delete;\n }\n"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "The body (content) of a message can be stored in various ways.  In this\nmanual-page you find the description of extra functionality you have\nwhen a message contains a nested message, like C<message/rfc822>.\n\nA nested message is different from a multipart message which contains\nonly one element, because a nested message has a full set of message\nheader fields defined by the RFC882, where a part of a multipart has\nonly a few.  But because we do not keep track whether all fields are\npresented, a C<Mail::Message::Part> is used anyway.\n\nB<WARNING:> Since 2023, at least outlook started to interpret RFC6533\nincorrectly.  Bodies of type 'message/rfc822' can only be 'nested', but\nwhen they (illegally) have Content-Transfer-Encoding, they can now behave\nlike normal message parts (the same as a pdf or image).\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Access to the payload",
                     "name" : "Access to the payload",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "name" : "Mail::Message::Body::Nested",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message"
      },
      "Mail::Message::Field::Address" : {
         "chapters" : [
            {
               "path" : "NAME",
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Field::Address - One e-mail address\n"
            },
            {
               "description" : " my $addr = Mail::Message::Field::Address->new(...);\n\n my $ui   = User::Identity->new(...);\n my $addr = Mail::Message::Field::Address->coerce($ui);\n\n my $mi   = Mail::Identity->new(...);\n my $addr = Mail::Message::Field::Address->coerce($mi);\n\n print $addr->address;\n print $addr->fullName;   # possibly unicode!\n print $addr->domain;\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "Many header fields can contain e-mail addresses.  Each e-mail address\ncan be represented by an object of this class.  These objects will\nhandle interpretation and character set encoding and decoding for you.\n",
               "level" : 1
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "type" : "Section",
                     "name" : "Constructors",
                     "level" : 2,
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "path" : "METHODS/Accessors",
                     "level" : 2,
                     "name" : "Accessors",
                     "type" : "Section"
                  },
                  {
                     "path" : "METHODS/Access to the content",
                     "level" : 2,
                     "name" : "Access to the content",
                     "type" : "Section"
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "One e-mail address",
         "name" : "Mail::Message::Field::Address",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/Address.pm",
         "package" : "Mail::Message::Field::Address"
      },
      "Mail::Message::Construct::Forward" : {
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Construct::Forward - forwarding a Mail::Message\n",
               "level" : 1
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my Mail::Message $forward = $message->forward(To => 'you');\n $forward->send;\n"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Complex functionality on M<Mail::Message> objects is implemented in\ndifferent files which are autoloaded.  This file implements the\nfunctionality related to creating forwarded messages.\n",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructing a message",
                     "type" : "Section",
                     "name" : "Constructing a message",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter"
            },
            {
               "type" : "Chapter",
               "name" : "DETAILS",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "DETAILS/Creating a forward",
                     "nest" : [
                        {
                           "type" : "Subsection",
                           "name" : "forward, specify a body",
                           "level" : 3,
                           "description" : "When you specify M<forward(body)>, you have created your own body object to\nbe used as content of the forwarded message.  This implies that\nM<forward(include)> is C<'NO'>: no automatic generation of the forwarded\nbody.\n",
                           "path" : "DETAILS/Creating a forward/forward, specify a body"
                        },
                        {
                           "path" : "DETAILS/Creating a forward/forward, inline the original",
                           "name" : "forward, inline the original",
                           "type" : "Subsection",
                           "description" : "The M<forward(include)> is set to C<'INLINE'> (the default)\nThis is the most complicated situation, but most often used by MUAs:\nthe original message is inserted textually in the new body.  You can\nset-up automatic stripping of signatures, the way of encapsulation,\nand texts which should be added before and after the encapsulated part.\n\nHowever, the result may not always be what you expect.  For instance,\nsome people use very long signatures which will not be automatically\nstripped because the pass the threshold.  So, you probably need some\nmanual intervention after the message is created and before it is sent.\n\nWhen a binary message is encountered, inlining is impossible.  In that\ncase, the message is treated as if C<'ENCAPSULATE'> was requested.\n",
                           "level" : 3
                        },
                        {
                           "path" : "DETAILS/Creating a forward/forward, attach the original",
                           "description" : "When M<forward(include)> is explicitly set to C<'ATTACH'> the result\nwill be a multipart which contains two parts.  The first part will\nbe your message, and the second the body of the original message.\n\nThis means that the headers of the forwarded message are used for\nthe new message, and detached from the part which now contains the\noriginal body information.  Content related headers will (of course)\nstill be part of that part, but lines line C<To> and C<Subject> will\nnot be stored with that part.\n\nAs example of the structural transformation:\n\n # code: $original->printStructure;\n multipart/alternative: The source message\n   text/plain: content in raw text\n   text/html: content as html\n\n # code: $fwd = $original->forward(include => 'ATTACH');\n # code: $fwd->printStructure\n multipart/mixed: The source message\n   text/plain: prelude/postlude/signature\n   multipart/alternative\n     text/plain: content in raw text\n     text/html: content as html\n",
                           "level" : 3,
                           "name" : "forward, attach the original",
                           "type" : "Subsection"
                        },
                        {
                           "path" : "DETAILS/Creating a forward/forward, encapsulate the original",
                           "name" : "forward, encapsulate the original",
                           "type" : "Subsection",
                           "description" : "When M<forward(include)> is explicitly set to C<'ENCAPSULATE'>, then\nthe original message is left in-tact as good as possible.  The lines\nof the original message are used in the main message header but also\nenclosed in the part header.\n\nThe encapsulation is implemented using a nested message, content type\nC<message/rfc822>.  As example of the structural transformation:\n\n # code: $original->printStructure;\n multipart/alternative: The source message\n   text/plain: content in raw text\n   text/html: content as html\n\n # code: $fwd = $original->forward(include => 'ENCAPSULATE');\n # code: $fwd->printStructure\n multipart/mixed: The source message\n   text/plain: prelude/postlude/signature\n   message/rfc822\n      multipart/alternative: The source message\n         text/plain: content in raw text\n         text/html: content as html\n\nThe message structure is much more complex, but no information is lost.\nThis is probably the reason why many MUAs use this when the forward\nan original message as attachment.\n",
                           "level" : 3
                        }
                     ],
                     "description" : "The main difference between M<bounce()> and M<forward()> is the reason\nfor message processing.  The I<bounce> has no intention to modify the\ncontent of message: the same information is passed-on to someplace else.\nThis may mean some conversions, but for instance, the Message-ID does\nnot need to be changed.\n\nThe purpose of I<forward()> is to pass on information which is\nmodified: annotated or reduced.  The information is not sent back\nto the author of the original message (which is implemented by M<reply()>),\nbut to someone else.\n\nSo: some information comes in, is modified, and than forwarded to someone\nelse.  Currently, there are four ways to get the original information\nincluded, which are explained in the next sections.\n\nAfter the creation of the forward, you may want to M<rebuild()> the\nmessage to remove unnecessary complexities.  Of course, that is not\nrequired.\n",
                     "level" : 2,
                     "name" : "Creating a forward",
                     "type" : "Section"
                  }
               ],
               "path" : "DETAILS"
            }
         ],
         "title" : "forwarding a Mail::Message",
         "name" : "Mail::Message::Construct::Forward",
         "package" : "Mail::Message",
         "source" : "lib/Mail/Message/Construct/Forward.pm",
         "version" : "3.018"
      },
      "Mail::Message::Field::URIs" : {
         "name" : "Mail::Message::Field::URIs",
         "title" : "message header field with uris",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Field::URIs - message header field with uris\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " my $f = Mail::Message::Field->new('List-Post' => 'http://x.org/');\n\n my $g = Mail::Message::Field->new('List-Post');\n $g->addURI('http://x.org');\n\n my $uri = URI->new(...);\n $g->addURI($uri);\n\n my @uris = $g->URIs;\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "More recent RFCs prefer uri field notation over the various differentiated\nsyntaxes.  Especially the mailing-list RFCs use these fields all the\ntime.  This class can maintain these fields.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "type" : "Section",
                     "name" : "Constructors",
                     "level" : 2
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Access to the content",
                     "path" : "METHODS/Access to the content"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "level" : 2,
                     "name" : "Error handling",
                     "type" : "Section"
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/URIs.pm",
         "package" : "Mail::Message::Field::URIs"
      },
      "Mail::Message::Construct::Read" : {
         "package" : "Mail::Message",
         "source" : "lib/Mail/Message/Construct/Read.pm",
         "version" : "3.018",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Construct::Read - read a Mail::Message from a file handle\n",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my $msg1 = Mail::Message->read(\\*STDIN);\n my $msg2 = Mail::Message->read(\\@lines);\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "description" : "When complex methods are called on a C<Mail::Message> object, this package\nis autoloaded to support the reading of messages directly from any file\nhandle.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "type" : "Section",
                     "name" : "Constructing a message",
                     "level" : 2,
                     "path" : "METHODS/Constructing a message"
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "title" : "read a Mail::Message from a file handle",
         "name" : "Mail::Message::Construct::Read"
      },
      "Mail::Message::Construct::Reply" : {
         "name" : "Mail::Message::Construct::Reply",
         "title" : "reply to a Mail::Message",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Construct::Reply - reply to a Mail::Message\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "description" : " my Mail::Message $reply = $message->reply;\n my $quoted  = $message->replyPrelude($head->get('From'));\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Complex functionality on M<Mail::Message> objects is implemented in\ndifferent files which are autoloaded.  This file implements the\nfunctionality related to creating message replies.\n"
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructing a message",
                     "name" : "Constructing a message",
                     "type" : "Section",
                     "level" : 2
                  }
               ]
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Construct/Reply.pm",
         "package" : "Mail::Message"
      },
      "Mail::Message::Head::ListGroup" : {
         "source" : "lib/Mail/Message/Head/ListGroup.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Head::ListGroup",
         "name" : "Mail::Message::Head::ListGroup",
         "title" : "mailinglist related header fields",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Head::ListGroup - mailinglist related header fields\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "level" : 1,
               "description" : " my $lg = Mail::Message::Head::ListGroup->new(head => $head, ...);\n $head->addListGroup($lg);\n\n my $lg = $head->addListGroup(...);\n\n $lg->delete;\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "A I<list group> is a set of header fields which are added by mailing-list\nmanaging software.  This class knowns various details about that software.\n\nThe knowledge and test messages which are used to initially implement\nthis module is taken from M<Mail::ListDetector>, written by\nMichael Stevens <mailto:michael@etla.org>.  The logic is redesigned to\nadd flexibility and use the powerful MailBox features.\n",
               "level" : 1
            },
            {
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Constructors"
                  },
                  {
                     "level" : 2,
                     "name" : "Access to the header",
                     "type" : "Section",
                     "path" : "METHODS/Access to the header"
                  },
                  {
                     "level" : 2,
                     "name" : "Internals",
                     "type" : "Section",
                     "path" : "METHODS/Internals"
                  },
                  {
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2,
                     "path" : "METHODS/Error handling"
                  }
               ]
            },
            {
               "path" : "DETAILS",
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "Mailing list fields",
                     "type" : "Section",
                     "path" : "DETAILS/Mailing list fields",
                     "nest" : [
                        {
                           "level" : 3,
                           "description" : "The M<Mail::Message::Head::ListGroup> class can detect many different\nmailing lists, some of which are very popular and some of which are\nrare.\n\nNumerous fields in a header are added when the message is passed\nthrough a mailing list server.  Each list software has defined its own\nfields, sometimes woth conflicting definitions.  There are also two\nRFCs about mailing list: C<rfc2919> and C<rfc2369>.\n\nThe following lists are currently detected.  Between parenthesis is\nthe string returned by M<type()> when that differs from the software\nname.\n\n\n=over 4\n\n=item * CommuniGate\n\nLegacy commercial MacOS implementation by Stalker Software Inc.\nL<http://www.stalker.com/mac/default.html>\n\n\n=item * CommuniGate Pro (CommuniGatePro)\nCommercial rfc2919 compliant implementation by Stalker Software Inc.\nL<http://www.stalker.com>\n\n\n=item * Ecartis\nCommercial mailing list manager, formerly known as Listar. Produced\nby NodeRunner Computing.  See L<http://www.ecartis.com>.\n\n\n=item * Ezmlm\nOpen Source mailing list manager, available from L<http://www.ezmlm.org>.\n\n\n=item * FML\nOpen Source mailing list manager, see L<http://www.fml.org>.\n\n\n=item * Listar\nOld name for Ecartis.\n\n\n=item * Listbox\nMailing lists defined at L<http://listbox.com>.\n\n\n=item * Mailman\nGNU's mailing list manager, available from L<http://www.list.org>.\n\n\n=item * Majordomo\nFree (licenced) mailing list manager by Great Circle Associates,\navailable from L<http://www.greatcircle.com/majordomo/>\n\n\n=item * Smartlist\nRelated to procmail, as expressed by their shared main page at\nL<http://www.procmail.org/>.\n\n\n=item * Yahoo! Groups (YahooGroups)\nMailing lists defined at L<http://groups.yahoo.com>.\n\n\n=item * Listserv\nCommercial mailing list manager, produced by L-Soft. See\nL<http://www.lsoft.com/>.\n\n\n=back\n",
                           "type" : "Subsection",
                           "name" : "Detected lists",
                           "path" : "DETAILS/Mailing list fields/Detected lists"
                        }
                     ]
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "DETAILS"
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0
      },
      "Mail::Message::Head::SpamGroup" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Head::SpamGroup",
         "title" : "spam fighting related header fields",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Head::SpamGroup - spam fighting related header fields\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my $sg = Mail::Message::Head::SpamGroup->new(head => $head, ...);\n $head->addSpamGroup($sg);\n\n my $sg = $head->addSpamGroup( <options> );\n $sg->delete;\n \n my @sgs = $head->spamGroups;\n",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "A I<spam group> is a set of header fields which are added by spam detection\nand spam fighting software.  This class knows various details about\nthat software.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "level" : 2,
                     "name" : "Constructors",
                     "type" : "Section"
                  }
               ],
               "path" : "METHODS"
            },
            {
               "path" : "DETAILS",
               "nest" : [
                  {
                     "path" : "DETAILS/Spam fighting fields",
                     "nest" : [
                        {
                           "name" : "Detected spam fighting software",
                           "type" : "Subsection",
                           "description" : "The M<Mail::Message::Head::SpamGroup> class can be used to detect\nfields which were produced by different spam fighting software.\n\n\n=over 4\n\n=item * SpamAssassin\nThese fields are added by L<Mail::SpamAssassin>, which is the central\nimplementation of the spam-assassin package.  The homepage of this\nGPL'ed project can be found at L<http://spamassassin.org>.\n\n\n=item * Habeas-SWE\nHabeas tries to fight spam via the standard copyright protection\nmechanism: Sender Warranted E-mail (SWE). Only when you have a contract\nwith Habeas, you are permitted to add a few copyrighted lines to your\ne-mail. Spam senders will be refused a contract.  Mail clients which\nsee these nine lines are (quite) sure that the message is sincere.\n\nSee L<http://www.habeas.com> for all the details on this commercial\nproduct.\n\n\n=item * MailScanner\nThe MailScanner filter is developed and maintained by\ntranstec Computers.  The software is available for free download from\nL<http://www.sng.ecs.soton.ac.uk/mailscanner/>.  Commercial support\nis provided via L<http://www.mailscanner.biz>.\n\n\n=back\n",
                           "level" : 3,
                           "path" : "DETAILS/Spam fighting fields/Detected spam fighting software"
                        }
                     ],
                     "level" : 2,
                     "name" : "Spam fighting fields",
                     "type" : "Section"
                  }
               ],
               "level" : 1,
               "name" : "DETAILS",
               "type" : "Chapter"
            }
         ],
         "package" : "Mail::Message::Head::SpamGroup",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Head/SpamGroup.pm"
      },
      "Mail::Message::Convert::EmailSimple" : {
         "source" : "lib/Mail/Message/Convert/EmailSimple.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Convert::EmailSimple",
         "name" : "Mail::Message::Convert::EmailSimple",
         "title" : "translate Mail::Message to Email::Simple vv",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Convert::EmailSimple - translate Mail::Message to Email::Simple vv\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " use Mail::Message::Convert::EmailSimple;\n my $convert = Mail::Message::Convert::EmailSimple->new;\n\n my Mail::Message $msg    = M<Mail::Message>->new;\n my Email::Simple $intern = $convert->export($msg);\n\n my Email::Simple $intern = M<Mail::Internet>->new;\n my Mail::Message $msg    = $convert->from($intern);\n\n use M<Mail::Box::Manager>;\n my $mgr     = Mail::Box::Manager->new;\n my $folder  = $mgr->open(folder => 'Outbox');\n $folder->addMessage($intern);\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "The M<Email::Simple> class is one of the base objects used by the\nlarge set of Email* modules, which implement many e-mail needs\nwhich are also supported by MailBox.  You can use this class to\ngradularly move from a Email* based implementation into a MailBox\nimplementation.\n\nThe internals of this class are far from optimal.  The conversion\ndoes work (thanks to Ricardo Signes), but is expensive in time\nand memory usage.  It could easily be optimized.\n"
            },
            {
               "nest" : [
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Converting",
                     "path" : "METHODS/Converting"
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0
      },
      "Mail::Reporter" : {
         "package" : "Mail::Reporter",
         "source" : "lib/Mail/Reporter.pm",
         "version" : "3.018",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Reporter",
         "chapters" : [
            {
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Reporter - base-class and error reporter for Mail::Box\n",
               "level" : 1,
               "path" : "NAME"
            },
            {
               "description" : " $folder->log(WARNING => 'go away');\n print $folder->trace;        # current level\n $folder->trace('PROGRESS');  # set level\n print $folder->errors;\n print $folder->report('PROGRESS');\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "The C<Mail::Reporter> class is the base class for all classes, except\nM<Mail::Message::Field::Fast> because it would become slow...  This\nbase class is used during initiation of the objects, and for configuring\nand logging error messages.\n",
               "level" : 1
            },
            {
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "Constructors",
                     "type" : "Section",
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "name" : "Attributes",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Attributes"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "name" : "Error handling",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Cleanup",
                     "level" : 2,
                     "name" : "Cleanup",
                     "type" : "Section"
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "description" : "The C<Mail::Reporter> class is the base for nearly all other\nobjects.  It can store and report problems, and contains the general\nconstructor M<new()>.\n",
               "level" : 1
            }
         ],
         "title" : "base-class and error reporter for Mail::Box"
      },
      "Mail::Message::Body::Encode" : {
         "package" : "Mail::Message::Body",
         "source" : "lib/Mail/Message/Body/Encode.pm",
         "version" : "3.018",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Body::Encode - organize general message encodings\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(mime_type => 'image/gif',\n     transfer_encoding => 'base64');\n\n my $body = $msg->body;\n my $decoded = $body->decoded;\n my $encoded = $body->encode(transfer_encoding => '7bit');\n",
               "path" : "SYNOPSIS"
            },
            {
               "description" : "Manages the message's body encodings and decodings on request of the\nmain program.  This package adds functionality to the M<Mail::Message::Body>\nclass when the M<decoded()> or M<encode()> method is called.\n\nFour types of encodings are handled (in the right order)\n\n\n=over 4\n\n\n=item * eol encoding\n\nVarious operating systems have different ideas about how to encode the\nline termination.  UNIX uses a LF character, MacOS uses a CR, and\nWindows uses a CR/LF combination.  Messages which are transported over\nInternet will always use the CRLF separator.\n\n\n=item * transfer encoding\n\nMessages transmitted over Internet have to be plain ASCII.  Complicated\ncharacters and binary files (like images and archives) must be encoded\nduring transmission to an ASCII representation.\n\nThe implementation of the required encoders and decoders is found in\nthe M<Mail::Message::TransferEnc> set of packages.  The related\nmanual page lists the transfer encodings which are supported.\n\n\n=item * mime-type translation\n\nNOT IMPLEMENTED YET\n\n\n=item * charset conversion\n\n\n=back\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS",
               "path" : "METHODS",
               "nest" : [
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Attributes",
                     "path" : "METHODS/Attributes"
                  },
                  {
                     "name" : "Constructing a body",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Constructing a body"
                  },
                  {
                     "name" : "About the payload",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/About the payload"
                  },
                  {
                     "path" : "METHODS/Internals",
                     "level" : 2,
                     "name" : "Internals",
                     "type" : "Section"
                  }
               ]
            }
         ],
         "title" : "organize general message encodings",
         "name" : "Mail::Message::Body::Encode"
      },
      "Mail::Message::Construct::Build" : {
         "package" : "Mail::Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Construct/Build.pm",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Construct::Build - building a Mail::Message from components\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my $msg1 = Mail::Message->build\n   ( From => 'me', data => \"only two\\nlines\\n\");\n\n my $msg2 = Mail::Message->buildFromBody($body);\n\n Mail::Message->build\n   ( From     => 'me@myhost.com'\n   , To       => 'you@yourhost.com'\n   , Subject  => \"Read our folder!\"\n\n   , data     => \\@lines\n   , file     => 'folder.pdf'\n   )->send(via => 'postfix');\n"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "Complex functionality on M<Mail::Message> objects is implemented in\ndifferent files which are autoloaded.  This file implements the\nbuilding of messages from various simpler components.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1,
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "Constructing a message",
                     "type" : "Section",
                     "path" : "METHODS/Constructing a message"
                  }
               ],
               "path" : "METHODS"
            },
            {
               "path" : "DETAILS",
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "Building a message",
                     "type" : "Section",
                     "path" : "DETAILS/Building a message",
                     "nest" : [
                        {
                           "description" : "Most messages you need to construct are relatively simple.  Therefore,\nthis module provides a method to prepare a message with only one method\ncall: M<build()>.\n",
                           "level" : 3,
                           "name" : "Rapid building",
                           "type" : "Subsection",
                           "path" : "DETAILS/Building a message/Rapid building"
                        },
                        {
                           "path" : "DETAILS/Building a message/Compared to MIME::Entity::build()",
                           "level" : 3,
                           "description" : "The C<build> method in MailBox is modelled after the C<build> method\nas provided by MIMETools, but with a few simplifications:\n\n\n=over 4\n\n=item When a keys starts with a capital, than it is always a header field\n\n=item When a keys is lower-cased, it is always something else\n\n=item You use the real field-names, not abbreviations\n\n=item All field names are accepted\n\n=item You may specify field objects between key-value pairs\n\n=item A lot of facts are auto-detected, like content-type and encoding\n\n=item You can create a multipart at once\n\n=back\n\nHum, reading the list above... what is equivalent?  L<MIME::Entity> is\nnot that simple after all!  Let's look at an example from MIME::Entity's\nmanual page:\n\n ### Create the top-level, and set up the mail headers:\n $top = MIME::Entity->build(Type     => \"multipart/mixed\",\n                            From     => 'me@myhost.com',\n                            To       => 'you@yourhost.com',\n                            Subject  => \"Hello, nurse!\");\n                                                                                \n ### Attachment #1: a simple text document:\n $top->attach(Path=>\"./testin/short.txt\");\n                                                                                \n ### Attachment #2: a GIF file:\n $top->attach(Path        => \"./docs/mime-sm.gif\",\n              Type        => \"image/gif\",\n              Encoding    => \"base64\");\n                                                                                \n ### Attachment #3: text we'll create with text we have on-hand:\n $top->attach(Data => $contents);\n                                                                                \nThe MailBox equivalent could be\n\n my $msg = Mail::Message->build\n   ( From     => 'me@myhost.com'\n   , To       => 'you@yourhost.com'\n   , Subject  => \"Hello, nurse!\"\n\n   , file     => \"./testin/short.txt\"\n   , file     => \"./docs/mime-sm.gif\"\n   , data     => $contents\n   );\n\nOne of the simplifications is that M<MIME::Types> is used to lookup\nthe right content type and optimal transfer encoding.  Good values\nfor content-disposition and such are added as well.\n",
                           "type" : "Subsection",
                           "name" : "Compared to MIME::Entity::build()"
                        },
                        {
                           "type" : "Subsection",
                           "name" : "build, starting with nothing",
                           "level" : 3,
                           "description" : "See M<build()>.\n",
                           "path" : "DETAILS/Building a message/build, starting with nothing"
                        },
                        {
                           "path" : "DETAILS/Building a message/buildFromBody, body becomes message",
                           "description" : "See M<buildFromBody()>.\n",
                           "level" : 3,
                           "name" : "buildFromBody, body becomes message",
                           "type" : "Subsection"
                        },
                        {
                           "path" : "DETAILS/Building a message/The Content-* fields",
                           "description" : "The various C<Content-*> fields are not as harmless as they look.  For\ninstance, the \"Content-Type\" field will have an effect on the default\ntransfer encoding.\n\nWhen a message is built this way:\n\n my $msg = Mail::Message->build\n  ( 'Content-Type' => 'video/mpeg3'\n  , 'Content-Transfer-Encoding' => 'base64'\n  , 'Content-Disposition' => 'attachment'\n  , file => '/etc/passwd'\n  );\n\nthen first a C<text/plain> body is constructed (MIME::Types does not\nfind an extension on the filename so defaults to C<text/plain>), with\nno encoding.  Only when that body is ready, the new type and requested\nencodings are set.  The content of the body will get base64 encoded,\nbecause it is requested that way.\n\nWhat basically happens is this:\n\n my $head = ...other header lines...;\n my $body = Mail::Message::Body::Lines->new(file => '/etc/passwd');\n $body->type('video/mpeg3');\n $body->transferEncoding('base64');\n $body->disposition('attachment');\n my $msg  = Mail::Message->buildFromBody($body, $head);\n \nA safer way to construct the message is:\n\n my $body = Mail::Message::Body::Lines->new\n  ( file              => '/etc/passwd'\n  , mime_type         => 'video/mpeg3'\n  , transfer_encoding => 'base64'\n  , disposition       => 'attachment'\n  );\n\n my $msg  = Mail::Message->buildFromBody\n  ( $body\n  , ...other header lines...\n  );\n\nIn the latter program, you will immediately start with a body of\nthe right type.\n",
                           "level" : 3,
                           "name" : "The Content-* fields",
                           "type" : "Subsection"
                        }
                     ]
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "DETAILS"
            }
         ],
         "title" : "building a Mail::Message from components",
         "name" : "Mail::Message::Construct::Build"
      },
      "Mail::Message::Head::Complete" : {
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Head::Complete - the header of one message\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my $head = Mail::Message::Head::Complete->new;\n See Mail::Message::Head\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "E-mail's message can be in various states: unread, partially read, and\nfully read.  The class stores a message of which all header lines are\nknown for sure.\n"
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS",
               "path" : "METHODS",
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "Constructors",
                     "type" : "Section",
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "path" : "METHODS/The header",
                     "level" : 2,
                     "name" : "The header",
                     "type" : "Section"
                  },
                  {
                     "path" : "METHODS/Access to the header",
                     "type" : "Section",
                     "name" : "Access to the header",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "About the body",
                     "level" : 2,
                     "path" : "METHODS/About the body"
                  },
                  {
                     "type" : "Section",
                     "name" : "Internals",
                     "level" : 2,
                     "path" : "METHODS/Internals"
                  }
               ]
            }
         ],
         "title" : "the header of one message",
         "name" : "Mail::Message::Head::Complete",
         "package" : "Mail::Message::Head::Complete",
         "source" : "lib/Mail/Message/Head/Complete.pm",
         "version" : "3.018"
      },
      "Mail::Message::Field::AddrGroup" : {
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/AddrGroup.pm",
         "package" : "Mail::Message::Field::AddrGroup",
         "name" : "Mail::Message::Field::AddrGroup",
         "chapters" : [
            {
               "description" : "Mail::Message::Field::AddrGroup - A group of Mail::Message::Field::Address objects\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter",
               "path" : "NAME"
            },
            {
               "level" : 1,
               "description" : " my $g = Mail::Message::Field::AddrGroup->new(name => 'name');\n\n my $a = Mail::Message::Field::Address->new(...);\n $g->addAddress($a);\n \n my $f = Mail::Message::Field::Addresses->new;\n $f->addGroup($g);\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "An address group collects a set of e-mail addresses (in this case they\nare M<Mail::Message::Field::Address> objects).\n",
               "level" : 1,
               "path" : "DESCRIPTION"
            },
            {
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "type" : "Section",
                     "name" : "Constructors",
                     "level" : 2
                  },
                  {
                     "level" : 2,
                     "name" : "Addresses",
                     "type" : "Section",
                     "path" : "METHODS/Addresses"
                  },
                  {
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2,
                     "path" : "METHODS/Error handling"
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "A group of Mail::Message::Field::Address objects",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0
      },
      "Mail::Message::Body" : {
         "name" : "Mail::Message::Body",
         "title" : "the data of a body in a message",
         "chapters" : [
            {
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Body - the data of a body in a message\n",
               "level" : 1,
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my Mail::Message $msg = ...;\n my $body  = $msg->body;\n my @text  = $body->lines;\n my $text  = $body->string;\n my $file  = $body->file;  # IO::File\n $body->print(\\*FILE);\n\n my $content_type = $body->type;\n my $transfer_encoding = $body->transferEncoding;\n my $encoded = $body->encode(mime_type => 'text/html',\n    charset => 'us-ascii', transfer_encoding => 'none');\\n\";\n my $decoded = $body->decoded;\n"
            },
            {
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "The encoding and decoding functionality of a M<Mail::Message::Body> is\nimplemented in the M<Mail::Message::Body::Encode> package.  That package is\nautomatically loaded when encoding and decoding of messages needs to take\nplace.  Methods to simply build an process body objects are implemented\nin M<Mail::Message::Body::Construct>.\n\nThe body of a message (a M<Mail::Message> object) is stored in one of the\nmany body types.  The functionality of each body type is equivalent, but there\nare performance differences.  Each body type has its own documentation\nwith details about its implementation.\n",
               "level" : 1,
               "path" : "DESCRIPTION"
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS",
               "path" : "METHODS",
               "nest" : [
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Constructors",
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "path" : "METHODS/Constructing a body",
                     "name" : "Constructing a body",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "name" : "The body",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/The body"
                  },
                  {
                     "path" : "METHODS/About the payload",
                     "type" : "Section",
                     "name" : "About the payload",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Access to the payload",
                     "type" : "Section",
                     "name" : "Access to the payload",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Internals",
                     "type" : "Section",
                     "name" : "Internals",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Error handling"
                  }
               ]
            },
            {
               "path" : "DETAILS",
               "nest" : [
                  {
                     "path" : "DETAILS/Access to the body",
                     "level" : 2,
                     "description" : "A body can be contained in a message, but may also live without a message.\nIn both cases it stores data, and the same questions can be asked: what\ntype of data it is, how many bytes and lines, what encoding is used.  Any\nbody can be encoded and decoded, returning a new body object.  However,\nbodies which are part of a message will always be in a shape that they can\nbe written to a file or send to somewhere: they will be encoded if needed.\n",
                     "type" : "Section",
                     "name" : "Access to the body"
                  },
                  {
                     "level" : 2,
                     "description" : "The body of a message can be stored in many ways.  Roughly, the\nimplementations can be split in two groups: the data collectors and\nthe complex bodies. The primer implement various ways to access data,\nand are full compatible: they only differ in performance and memory\nfootprint under different circumstances.  The latter are created to\nhandle complex multiparts and lazy extraction.\n",
                     "type" : "Section",
                     "name" : "Body class implementation",
                     "path" : "DETAILS/Body class implementation",
                     "nest" : [
                        {
                           "name" : "Data collector bodies",
                           "type" : "Subsection",
                           "description" : "=over 4\n\n\n=item * M<Mail::Message::Body::String>\nThe whole message body is stored in one scalar.  Small messages can be\ncontained this way without performance penalties.\n\n\n=item * M<Mail::Message::Body::Lines>\nEach line of the message body is stored as single scalar.  This is a\nuseful representation for a detailed look in the message body, which is\nusually line-organized.\n\n\n=item * M<Mail::Message::Body::File>\nThe message body is stored in an external temporary file.  This type of\nstorage is especially useful when the body is large, the total folder is\nlarge, or memory is limited.\n\n\n=item * Mail::Message::Body::InFolder\nNOT IMPLEMENTED YET.\nThe message is kept in the folder, and is only taken out when the\ncontent is changed.\n\n\n=item * Mail::Message::Body::External\nNOT IMPLEMENTED YET.\nThe message is kept in a separate file, usually because the message body\nis large.  The difference with the C<::External> object is that this external\nstorage stays this way between closing and opening of a folder. The\nC<::External> object only uses a file when the folder is open.\n\n\n=back\n",
                           "level" : 3,
                           "path" : "DETAILS/Body class implementation/Data collector bodies"
                        },
                        {
                           "path" : "DETAILS/Body class implementation/Complex bodies",
                           "level" : 3,
                           "description" : "=over 4\n\n\n=item * M<Mail::Message::Body::Delayed>\nThe message-body is not yet read, but the exact location of the\nbody is known so the message can be read when needed.  This is part of\nthe lazy extraction mechanism.  Once extracted, the object can become\nany simple or complex body.\n\n\n=item * M<Mail::Message::Body::Multipart>\nThe message body contains a set of sub-messages (which can contain\nmultipart bodies themselves).  Each sub-message is an instance\nof M<Mail::Message::Part>, which is an extension of M<Mail::Message>.\n\n\n=item * M<Mail::Message::Body::Nested>\nNested messages, like C<message/rfc822>: they contain a message in\nthe body.  For most code, they simply behave like multiparts.\n\n\n=back\n",
                           "type" : "Subsection",
                           "name" : "Complex bodies"
                        }
                     ]
                  },
                  {
                     "nest" : [
                        {
                           "path" : "DETAILS/Character encoding PERL/Autodetection of character-set",
                           "description" : "This \"Body\" object represents data as part of an existing message, or\nto become part of a message.  The body can be in two states:\n\n\n=over 4\n\n=item 1. ready to be processed textually, using Perl's string operations\n\n=item 2. raw bytes read or to be written\n\n=back\n\nIn the first case, the body content has no transfer encoding on it\n(C<none>), and the character-set is C<PERL>.  In the second version,\nthe body may have transfer encoding and has an (IANA listed) charset\non it (defaults to C<us-ascii>)\n\nUsing M<encode()> (maybe via M<decoded()>), you can convert bodies from one\nstate into a different one.  In one go, you can change the transfer-encoding,\nthe character-set, or whether it is in PERL string format or raw (in bytes).\n\n[3.013] A serious problem is created when a conversion is needed, while the input\nor output character-set is not explicitly known.  The email RFCs state that\nthe default is C<us-ascii>.  However, in the real world it can be anything.\nTherefore, in such situations autodetection kicks in.\n\n\n=over 4\n\n=item 1.\nWhen a Body is read (using M<Mail::Message::read()> and friends), the\ncharacter-set may stay undefined until transfer-decoding has been applicied.\nAt that moment, (configurable auto-detection) is applied;\n\n=item 2.\nWhen a Body is created witin the program, without specific character-set,\nit will use 'PERL';\n\n=item 3.\nWhen a Body is written, the requested character-set is not specified, and the\ncurrent character-set is C<PERL>, then auto-dectection is used.  This may\nresult in C<us-ascii>, C<cp1252> and C<utf-8>;\n\n=item 4.\nIn all other cases, the character-set is known so \"easy\".\n\n=back\n",
                           "level" : 3,
                           "name" : "Autodetection of character-set",
                           "type" : "Subsection"
                        }
                     ],
                     "path" : "DETAILS/Character encoding PERL",
                     "name" : "Character encoding PERL",
                     "type" : "Section",
                     "description" : "A body object can be part of a message, or stand-alone.  In case it\nis a part of a message, the \"transport encoding\" and the content must\nbe in a shape that the data can be transported via SMTP.\n\nHowever, when you want to process the body data in simple Perl (or when\nyou construct the body data from normal Perl strings), you need to be\naware of Perl's internal representation of strings. That can either be\ncp1252 (extended latin1) or utf8 (not real UTF-8, but something alike,\nsee the perlunicode manual page)  So, before you start using the data\nfrom an incoming message, do\n\n    my $body  = $msg->decoded;\n    my @lines = $body->lines;\n\nNow, the body has character-set 'PERL' (when it is text)\n\nWhen you create a new body which contains text content (the default),\nit will be created with character-set 'PERL' unless you specify a\ncharacter-set explicitly.\n\n   my $body = Mail::Box::Body::Lines->new(data => \\@lines);\n   # now mime=text/plain, charset=PERL\n\n   my $msg  = Mail::Message->buildFromBody($body);\n   $msg->body($body);\n   $msg->attach($body);   # etc\n   # these all will convert the charset=PERL into real utf-8,\n   # cp1252 or us-ascii, which depends on the characters found.\n",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "name" : "DETAILS",
               "type" : "Chapter"
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "source" : "lib/Mail/Message/Body.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Body"
      },
      "Mail::Message::Field::Structured" : {
         "name" : "Mail::Message::Field::Structured",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Field::Structured - one line of a structured message header\n",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "level" : 1,
               "description" : " my $f = Mail::Message::Field::Full\n            ->new('Content-Type' => 'text/html');\n\n my @encode = (charset => 'jp', use_continuations => 1);\n $f->attribute('filename=passwd');\n $f->attribute(filename => 'passwd', @encode);\n\n my $attr = Mail::Message::Field::Attribute->new(...);\n $f->attribute($attr);\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Access to the content",
                     "type" : "Section",
                     "name" : "Access to the content",
                     "level" : 2
                  },
                  {
                     "level" : 2,
                     "name" : "Parsing",
                     "type" : "Section",
                     "path" : "METHODS/Parsing"
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "title" : "one line of a structured message header",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/Structured.pm",
         "package" : "Mail::Message::Field::Structured"
      },
      "Mail::Message::Field::Date" : {
         "package" : "Mail::Message::Field::Date",
         "source" : "lib/Mail/Message/Field/Date.pm",
         "version" : "3.018",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "title" : "message header field with uris",
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Field::Date - message header field with uris\n",
               "level" : 1
            },
            {
               "level" : 1,
               "description" : " my $f = Mail::Message::Field->new(Date => time);\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "Dates are a little more tricky than it should be: the formatting permits\na few constructs more than other RFCs use for timestamps.  For instance,\na small subset of timezone abbreviations are permitted.\n\nThe studied date field will reformat the content into a standard\nform.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "type" : "Section",
                     "name" : "Constructors",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Access to the content",
                     "type" : "Section",
                     "name" : "Access to the content",
                     "level" : 2
                  },
                  {
                     "name" : "Error handling",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Error handling"
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "name" : "Mail::Message::Field::Date"
      },
      "Mail::Message::Convert::HtmlFormatPS" : {
         "package" : "Mail::Message::Convert::HtmlFormatPS",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Convert/HtmlFormatPS.pm",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Convert::HtmlFormatPS",
         "chapters" : [
            {
               "description" : "Mail::Message::Convert::HtmlFormatPS - Convert HTML into PostScript\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter",
               "path" : "NAME"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " use Mail::Message::Convert::HtmlFormatPS;\n my $af = Mail::Message::Convert::HtmlFormatPS->new;\n\n my $postscript = $af->format($body);\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "description" : "Translate an HTML/XHTML message body into a postscript body\nusing M<HTML::FormatPS>.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Converting",
                     "name" : "Converting",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "title" : "Convert HTML into PostScript"
      },
      "Mail::Box::Parser" : {
         "source" : "lib/Mail/Box/Parser.pm",
         "version" : "3.018",
         "package" : "Mail::Box::Parser",
         "name" : "Mail::Box::Parser",
         "title" : "reading and writing messages",
         "chapters" : [
            {
               "path" : "NAME",
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Box::Parser - reading and writing messages\n"
            },
            {
               "description" : " # Not instatiatiated itself\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "path" : "SYNOPSIS"
            },
            {
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "The C<Mail::Box::Parser> manages the parsing of folders.  Usually, you won't\nneed to know anything about this module, except the options which are\ninvolved with this code.\n\nThere are currently three implementations of this module:\n\n\n=over 4\n\n\n=item * M<Mail::Box::Parser::C>\nA fast parser written in C<C>.  This package is released as separate\nmodule on CPAN, because the module distribution via CPAN can not\nhandle XS files which are not located in the root directory of the\nmodule tree.  If a C compiler is available on your system, it will be\nused automatically.\n\n\n=item * M<Mail::Box::Parser::Perl>\nA slower parser when the message is in a file, like mbox, which only\nuses plain Perl.  This module is a bit slower, and does less checking\nand less recovery.\n\n\n=item * M<Mail::Box::Parser::Lines>\nUseful when the message is already in memory.  When you plan to use this\nyourself, you probably need to use M<Mail::Message::Construct::Read>.\n\n=back\n",
               "level" : 1,
               "path" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "name" : "Attributes",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Attributes"
                  },
                  {
                     "path" : "METHODS/Parsing",
                     "nest" : [
                        {
                           "level" : 3,
                           "description" : "The various \"separators\" methods are used by M<Mail::Message::Body::Multipart>\nto detect parts, and for the file based mailboxes to flag where the new message\nstarts.\n",
                           "type" : "Subsection",
                           "name" : "Administering separators",
                           "path" : "METHODS/Parsing/Administering separators"
                        }
                     ],
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Parsing"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Error handling"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Cleanup",
                     "path" : "METHODS/Cleanup"
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0
      },
      "Mail::Message::Head::FieldGroup" : {
         "source" : "lib/Mail/Message/Head/FieldGroup.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Head::FieldGroup",
         "name" : "Mail::Message::Head::FieldGroup",
         "title" : "a sub set of fields in a header",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Head::FieldGroup - a sub set of fields in a header\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "path" : "SYNOPSIS",
               "description" : "Never instantiated directly.\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "Some fields have a combined meaning: a set of fields which represent\none intermediate step during the transport of the message (a\nI<resent group>, implemented in M<Mail::Message::Head::ResentGroup>), \nfields added by mailing list software (implemented in\nM<Mail::Message::Head::ListGroup>), or fields added by Spam detection\nrelated software (implemented by M<Mail::Message::Head::SpamGroup>).\nEach set of fields can be extracted or added as group with objects\nwhich are based on the implementation in this class.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Constructors"
                  },
                  {
                     "path" : "METHODS/The header",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "The header"
                  },
                  {
                     "path" : "METHODS/Access to the header",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Access to the header"
                  },
                  {
                     "name" : "Internals",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Internals"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0
      },
      "Mail::Message::Field::Full" : {
         "name" : "Mail::Message::Field::Full",
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Field::Full - construct one smart line in a message header\n",
               "level" : 1
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " # Getting to understand the complexity of a header field ...\n\n my $fast = $msg->head->get('subject');\n my $full = Mail::Message::Field::Full->from($fast);\n\n my $full = $msg->head->get('subject')->study;  # same\n my $full = $msg->head->study('subject');       # same\n my $full = $msg->study('subject');             # same\n\n # ... or build a complex header field yourself\n\n my $f = Mail::Message::Field::Full->new('To');\n my $f = Mail::Message::Field::Full->new('Subject: hi!');\n my $f = Mail::Message::Field::Full->new(Subject => 'hi!');\n"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "This is the I<full> implementation of a header field: it has I<full>\nunderstanding of all predefined header fields.  These objects will be\nquite slow, because header fields can be very complex.  Of course, this\nclass delivers the optimal result, but for a quite large penalty in\nperformance and memory consumption.  Are you willing to accept?\n\nThis class supports the common header description from RFC2822 (formerly\nRFC822), the extensions with respect to character set encodings as specified\nin RFC2047, and the extensions on language specification and long parameter\nwrapping from RFC2231.  If you do not need the latter two, then the\nM<Mail::Message::Field::Fast> and M<Mail::Message::Field::Flex>\nare enough for your application.\n\nRFC5322 (F<https://www.rfc-editor.org/rfc/rfc5322.html>) describes a\nlong list of obsolete syntax for structured header fields.  This mainly\nrefers to disallowing white-spaces and folding on many inconvenient\nlocations.  This matches MailBox's natural behavior.\n",
               "path" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "name" : "Constructors",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "Access to the body",
                     "level" : 2,
                     "path" : "METHODS/Access to the body"
                  },
                  {
                     "path" : "METHODS/Access to the content",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Access to the content"
                  },
                  {
                     "path" : "METHODS/Internals",
                     "name" : "Internals",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "description" : "You probably do not want to call these parsing methods yourself: use\nthe standard constructors (M<new()>) and it will be done for you.\n",
                     "level" : 2,
                     "name" : "Parsing",
                     "type" : "Section",
                     "path" : "METHODS/Parsing"
                  },
                  {
                     "level" : 2,
                     "name" : "Error handling",
                     "type" : "Section",
                     "path" : "METHODS/Error handling"
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "title" : "construct one smart line in a message header",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "source" : "lib/Mail/Message/Field/Full.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Field::Full"
      },
      "Mail::Message::Field::Addresses" : {
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/Addresses.pm",
         "package" : "Mail::Message::Field::Addresses",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Field::Addresses - Fields with e-mail addresses\n",
               "path" : "NAME"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : "  my $cc = Mail::Message::Field::Full->new('Cc');\n  my $me = Mail::Message::Field::Address->parse('\"Test\" <test@mail.box>')\n     or die;\n\n  my $other = Mail::Message::Field::Address->new(phrase => 'Other'\n     , address => 'other@example.com')\n     or die;\n\n  $cc->addAddress($me);\n  $cc->addAddress($other, group => 'them');\n  $cc->addAddress(phrase => 'third', address => 'more@any.museum'\n    , group => 'them');\n\n  my $group = $cc->addGroup(name => 'collegues');\n  $group->addAddress($me);\n  $group->addAddress(phrase => \"You\", address => 'you@example.com');\n\n  my $msg = Mail::Message->build(Cc => $cc);\n  print $msg->string;\n\n  my $g  = M<Mail::Message::Field::AddrGroup>->new(...);\n  $cc->addGroup($g);\n",
               "path" : "SYNOPSIS"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "All header fields which contain e-mail addresses only.  Not all address\nfields have the same possibilities, but they are all parsed the same:\nyou never know how broken the applications are which produce those\nmessages.\n\nWhen you try to create constructs which are not allowed for a certain\nkind of field, you will be warned.\n\nRFC5322 did allow address groups for \"To\" and \"Cc\", but not to be used\nin (amongst other) \"From\" and \"Sender\" fields.  This restriction got\nlifted by RFC6854 (2013).  F<https://www.rfc-editor.org/rfc/rfc6854>\n",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "type" : "Section",
                     "name" : "Access to the content",
                     "level" : 2,
                     "path" : "METHODS/Access to the content"
                  },
                  {
                     "path" : "METHODS/Parsing",
                     "level" : 2,
                     "name" : "Parsing",
                     "type" : "Section"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "title" : "Fields with e-mail addresses",
         "name" : "Mail::Message::Field::Addresses",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message"
      },
      "Mail::Message::Construct" : {
         "package" : "Mail::Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Construct.pm",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Construct",
         "chapters" : [
            {
               "description" : "Mail::Message::Construct - extends the functionality of a Mail::Message\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter",
               "path" : "NAME"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " # See M<Mail::Message>\n",
               "path" : "SYNOPSIS"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Complex functionality on M<Mail::Message> objects is implemented in\ndifferent files which are autoloaded.  This file implements the\nfunctionality related to creating message replies.\n\nThe following constructors are available:\n\n=over 4\n\n=item Mail::Message::Construct::Bounce\n\n=item Mail::Message::Construct::Build\n\n=item Mail::Message::Construct::Forward\n\n=item Mail::Message::Construct::Read\n\n=item Mail::Message::Construct::Rebuild\n\n=item Mail::Message::Construct::Reply\n\n=item Mail::Message::Construct::Text\n\n=back\n",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "title" : "extends the functionality of a Mail::Message"
      },
      "Mail::Message::Field::AuthResults" : {
         "name" : "Mail::Message::Field::AuthResults",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Field::AuthResults - message header field authentication result\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my $f = Mail::Message::Field->new('Authentication-Results' => '...');\n\n my $g = Mail::Message::Field->new('Authentication-Results');\n $g->addResult(method => 'dkim', result => 'fail');\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "Mail Transfer Agents may check the authenticity of an incoming message.\nThey add 'Authentication-Results' headers, maybe more than one.  This\nimplementation is based on RFC7601.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "name" : "Constructors",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Access to the content",
                     "path" : "METHODS/Access to the content"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Error handling"
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "message header field authentication result",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/AuthResults.pm",
         "package" : "Mail::Message::Field::AuthResults"
      },
      "Mail::Message::Body::Lines" : {
         "chapters" : [
            {
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Body::Lines - body of a Mail::Message stored as array of lines\n",
               "level" : 1,
               "path" : "NAME"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " See M<Mail::Message::Body>\n",
               "path" : "SYNOPSIS"
            },
            {
               "description" : "The body (content) of a message can be stored in various ways.  In this\ndocumentation you find the description of extra functionality you have\nwhen a message is stored in an array of lines.\n\nStoring a whole message as an array of lines is useful when the data is not\nencoded, and you want to process it on a line-by-line basis (a common practice\nfor inspecting message bodies).\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "title" : "body of a Mail::Message stored as array of lines",
         "name" : "Mail::Message::Body::Lines",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Body/Lines.pm",
         "package" : "Mail::Message::Body::Lines"
      },
      "Mail::Message::Body::Construct" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Body::Construct",
         "title" : "adds functionality to Mail::Message::Body",
         "chapters" : [
            {
               "path" : "NAME",
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Body::Construct - adds functionality to Mail::Message::Body\n"
            },
            {
               "path" : "SYNOPSIS",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "This package adds complex functionality to the M<Mail::Message::Body>\nclass.  This functions less often used, so many programs will not\ncompile this package.\n",
               "level" : 1,
               "path" : "DESCRIPTION"
            },
            {
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Constructing a body",
                     "type" : "Section",
                     "name" : "Constructing a body",
                     "level" : 2
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "package" : "Mail::Message::Body",
         "source" : "lib/Mail/Message/Body/Construct.pm",
         "version" : "3.018"
      },
      "Mail::Message::Field::Fast" : {
         "package" : "Mail::Message::Field::Fast",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/Fast.pm",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Field::Fast",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Field::Fast - one line of a message header\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "path" : "SYNOPSIS",
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " See M<Mail::Message::Field>\n",
               "level" : 1
            },
            {
               "description" : "This is the faster, but less flexible implementation of a header field.\nThe data is stored in an array, and some hacks are made to speeds\nthings up.  Be gentle with me, and consider that each message contains\nmany of these lines, so speed is very important here.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "title" : "one line of a message header"
      },
      "Mail::Box::FastScalar" : {
         "package" : "Mail::Box::FastScalar",
         "source" : "lib/Mail/Box/FastScalar.pm",
         "version" : "3.018",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Box::FastScalar",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Box::FastScalar - fast alternative to IO::Scalar\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "nest" : [
                  {
                     "path" : "DESCRIPTION/Warnings",
                     "description" : "You cannot modify the original reference between calls unless you\nC<$obj->seek(1, 0)> to reset the object - VERY rare usage case.\n\n$/ must be undef or string - \"\" and \\scalar unimplemented\n",
                     "level" : 2,
                     "name" : "Warnings",
                     "type" : "Section"
                  }
               ],
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "Extremely fast L<IO::Scalar> replacement - >20x improvement in\nC<getline()> and C<getlines()> methods.\n\nContributed by \"Todd Richmond\" (richmond@proofpoint.com)\n",
               "level" : 1
            }
         ],
         "title" : "fast alternative to IO::Scalar"
      },
      "Mail::Message::Construct::Text" : {
         "package" : "Mail::Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Construct/Text.pm",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Construct::Text",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Construct::Text - capture a Mail::Message as text\n",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my $text = $msg->string;\n my $text = \"$msg\";   # via overload\n\n my @text = $msg->lines;\n my @text = @$lines;  # via overload\n\n my $fh   = $msg->file;\n my $line = <$fh>;\n\n $msg->printStructure;\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "description" : "Complex functionality on M<Mail::Message> objects is implemented in\ndifferent files which are autoloaded.  This file implements the\nfunctionality related to creating message replies.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/The whole message as text",
                     "level" : 2,
                     "name" : "The whole message as text",
                     "type" : "Section"
                  },
                  {
                     "path" : "METHODS/Flags",
                     "name" : "Flags",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "title" : "capture a Mail::Message as text"
      },
      "Mail::Message::TransferEnc::Binary" : {
         "package" : "Mail::Message::TransferEnc::Binary",
         "source" : "lib/Mail/Message/TransferEnc/Binary.pm",
         "version" : "3.018",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::TransferEnc::Binary",
         "chapters" : [
            {
               "description" : "Mail::Message::TransferEnc::Binary - encode/decode binary message bodies\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter",
               "path" : "NAME"
            },
            {
               "level" : 1,
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(transfer => 'binary');\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Encode or decode message bodies for binary transfer encoding.  This is\ntotally no encoding.\n"
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS",
               "path" : "METHODS"
            }
         ],
         "title" : "encode/decode binary message bodies"
      },
      "Mail::Message::Construct::Rebuild" : {
         "chapters" : [
            {
               "path" : "NAME",
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message::Construct::Rebuild - modify a Mail::Message\n",
               "level" : 1
            },
            {
               "level" : 1,
               "description" : " my $cleanup = $msg->rebuild;\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "Modifying existing messages is a pain, certainly if this has to be\ndone in an automated fashion.  The problems are especially had when\nmultiparts have to be created or removed.  The M<rebuild()> method\ntries to simplify this task and add some standard features.\n",
               "level" : 1
            },
            {
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "Constructing a message",
                     "type" : "Section",
                     "path" : "METHODS/Constructing a message"
                  },
                  {
                     "path" : "METHODS/Internals",
                     "type" : "Section",
                     "name" : "Internals",
                     "level" : 2
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "DETAILS",
               "path" : "DETAILS",
               "nest" : [
                  {
                     "path" : "DETAILS/Rebuilding a message",
                     "nest" : [
                        {
                           "path" : "DETAILS/Rebuilding a message/General rules",
                           "type" : "Subsection",
                           "name" : "General rules",
                           "level" : 3,
                           "description" : "This sections describes the general configuration rules: all quite straight\nforward transformations on the message structure.  The rules marked with (*)\nare used by default.\n\n\n=over 4\n\n\n=item * descendMultiparts (*)\nApply the rules to the parts of (possibly nested) multiparts, not only to\nthe top-level message.\n\n\n=item * descendNested (*)\nApply the rules to the C<message/rfc822> encapsulated message as well.\n\n\n=item * flattenEmptyMultiparts (*)\nMultipart messages which do not have any parts left are replaced by\na single part which contains the preamble, epilogue and a brief\nexplanation.\n\n\n=item * flattenMultiparts (*)\nWhen a multipart contains only one part, that part will take the place of\nthe multipart: the removal of a level of nesting.  This way, the preamble\nand epilogue of the multipart (which do not have a meaning, officially)\nare lost.\n\n\n=item * flattenNesting\nRemove the C<message/rfc822> encapsulation.  Only the content related\nlines of the encapsulated body are preserved one level higher.  Other\ninformation will be lost, which is often not too bad.\n\n\n=item * removeDeletedParts\nAll parts which are flagged for deletion are removed from the message\nwithout leaving a trace.  If a nested message is encountered which has\nits encapsulated content flagged for deletion, it will be removed as\na whole.\n\n\n=item * removeEmptyMultiparts\nMultipart messages which do not have any parts left are removed.  The\ninformation in preamble and epiloge is lost.\n\n\n=item * removeEmptyBodies\nSimple message bodies which do not contain any lines of content are\nremoved.  This will loose the information which is stored in the\nheaders of these bodies.\n\n\n=item * replaceDeletedParts (*)\nAll parts of the message which are flagged for deletion are replace\nby a message which says that the part is deleted.\n\n\n=back\n\nYou can specify a selection of these rules with M<rebuild(rules)> and\nM<rebuild(extra_rules)>.\n"
                        },
                        {
                           "path" : "DETAILS/Rebuilding a message/Conversion rules",
                           "description" : "This section describes the rules which try to be smart with the\ncontent.  Please contribute with ideas and implementations.\n\n\n=over 4\n\n\n=item * removeHtmlAlternativeToText\nWhen a multipart alternative is encountered, which contains both a\nplain text and an html part, then the html part is deleted.\nEspecially useful in combination with the C<flattenMultiparts> rule.\n\n\n=item * textAlternativeForHtml\nAny C<text/html> part which is not accompanied by an alternative\nplain text part will have one added.  You must have a working\nM<Mail::Message::Convert::HtmlFormatText>, which means that\nM<HTML::TreeBuilder> and M<HTML::FormatText> must be installed on\nyour system.\n\nWhen you are planning to create an automatic html to plain text\nfilter for your email, then have a look at\nF<https://github.com/logological/mimestrip>\n",
                           "level" : 3,
                           "name" : "Conversion rules",
                           "type" : "Subsection"
                        },
                        {
                           "path" : "DETAILS/Rebuilding a message/Adding your own rules",
                           "level" : 3,
                           "description" : "If you have designed your own rule, please consider contributing this\nto Mail::Box; it may be useful for other people as well.\n\nEach rule is called\n\n my $new = $code->($message, $part, %options)\n\nwhere the C<%options> are defined by the C<rebuild()> method internals. At\nleast the C<rules> option is passed, which is a full expansion of all\nthe rules which will be applied.\n\nYour subroutine shall return C<$part> if no changes are needed,\nC<undef> if the part should be removed, and any newly constructed\nC<Mail::Message::Part> when a change is required.  It is easiest to\nstart looking at the source code of this package, and copy from a\ncomparible routine.\n\nWhen you have your own routine, you simply call:\n\n my $rebuild_message = $message->rebuild\n  ( extra_rules => [ \\&my_own_rule, 'other_rule' ] );\n",
                           "type" : "Subsection",
                           "name" : "Adding your own rules"
                        }
                     ],
                     "level" : 2,
                     "description" : "Modifying an existing message is a complicated job.  Not only do you need\nto know what you are willing to change, but you have to take care about\nmultiparts (possibly nested in multiple levels), rfc822 encapsulated\nmessages, header field consistency, and so on.  The M<rebuild()> method\nlet you focus on the task, and takes care of the rest.\n\nThe M<rebuild()> method uses rules to transform the one message into an\nother.  If one or more of the rules apply, a new message will be returned.\nA simple numeric comparison tells whether the message has changed.  For\nexample\n\n print \"No change\"\n    if $message == $message->rebuild;\n\nTransformation is made with a set of rules.  Each rule performs only a\nsmall step, which makes is easily configurable.  The rules are ordered,\nand when one makes a change to the result, the result will be passed\nto all the rules again until no rule makes a change on the part anymore.\nA rule may also return C<undef> in which case the part will be removed\nfrom the (resulting) message.\n",
                     "type" : "Section",
                     "name" : "Rebuilding a message"
                  }
               ]
            }
         ],
         "title" : "modify a Mail::Message",
         "name" : "Mail::Message::Construct::Rebuild",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "source" : "lib/Mail/Message/Construct/Rebuild.pm",
         "version" : "3.018",
         "package" : "Mail::Message"
      },
      "Mail::Message::Body::Multipart" : {
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Body::Multipart - body of a message with attachments\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " See M<Mail::Message::Body>\n\n if($body->isMultipart) {\n    my @attachments = $body->parts;\n    my $attachment3 = $body->part(2);\n    my $before      = $body->preamble;\n    my $after       = $body->epilogue;\n    $body->part(1)->delete;\n }\n"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "The body (content) of a message can be stored in various ways.  In this\nmanual-page you find the description of extra functionality you have\nwhen a message contains attachments (parts).\n\nThe number of multipart alternatives is growing.  A full list is maintained\nby IANA af F<http://www.iana.org/assignments/media-types/media-types.xhtml#multipart>\n\n\n=over 4\n\n=item * multipart/mixed\n\n=item * multipart/alternative\n\n=item * multipart/related\n\n=item * multipart/report, RFC6522\n\n=item * multipart/signed, RFC1847\n\n=item * multipart/encrypted\n\n=item * multipart/multilingual, RFC8255 (unused)\n\n=back\n"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructing a body",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Constructing a body"
                  },
                  {
                     "path" : "METHODS/Access to the payload",
                     "type" : "Section",
                     "name" : "Access to the payload",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "title" : "body of a message with attachments",
         "name" : "Mail::Message::Body::Multipart",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "source" : "lib/Mail/Message/Body/Multipart.pm",
         "version" : "3.018",
         "package" : "Mail::Message::Body::Multipart"
      },
      "Mail::Message::TransferEnc::Base64" : {
         "package" : "Mail::Message::TransferEnc::Base64",
         "version" : "3.018",
         "source" : "lib/Mail/Message/TransferEnc/Base64.pm",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::TransferEnc::Base64",
         "title" : "encode/decode base64 message bodies",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::TransferEnc::Base64 - encode/decode base64 message bodies\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "path" : "SYNOPSIS",
               "level" : 1,
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(transfer => 'base64');\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Encode or decode message bodies with base64.  The e-mail protocol and\nuser agents can not handle binary data.  Therefore, binary data -but\neven sometimes non-binary data- is encoded into ASCII, this is\ntransportable.\n\nBase64 re-groups the bits of bytes, and maps them on characters. The\ndata contains bytes of 8 bits (an I<octet>).  These are repacked into\ngroups of 6 bits, pointing in an array of characters containing\nC<[A-Za-z0-9+/]>.  This way, three data bytes become 4 base64 bytes.\nThe encoded data will be trailed by C<'='> characters to align on\nfour bytes.\n",
               "path" : "DESCRIPTION"
            },
            {
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1,
               "path" : "METHODS"
            }
         ]
      },
      "Mail::Message::Convert::HtmlFormatText" : {
         "name" : "Mail::Message::Convert::HtmlFormatText",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Convert::HtmlFormatText - Convert HTML into Text\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "level" : 1,
               "description" : " use Mail::Message::Convert::HtmlFormatText;\n my $af = Mail::Message::Convert::HtmlFormatText->new;\n\n my $plain_body = $af->format($body);\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "level" : 1,
               "description" : "Convert HTML/XHTML message body objects into plain text bodies using\nM<HTML::FormatText>.  This package requires M<HTML::TreeBuilder> and\nM<HTML::FormatText> which are not installed by default together with\nMail::Box.  See also M<Mail::Message::rebuild()> with rule\nC<text_alternative_for_html>.\n\nThis module is a small wrapper around M<HTML::FormatText>.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "path" : "DESCRIPTION"
            },
            {
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Converting",
                     "name" : "Converting",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "Convert HTML into Text",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Convert/HtmlFormatText.pm",
         "package" : "Mail::Message::Convert::HtmlFormatText"
      },
      "Mail::Message::Head::ResentGroup" : {
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Head::ResentGroup - header fields tracking message delivery\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " use Mail::Message::Head::ResentGroup;\n my $rg = Mail::Message::Head::ResentGroup->new(head => $head,\n              From => 'me@home.nl', To => 'You@tux.aq');\n $head->addResentGroup($rg);\n\n my $rg = $head->addResentGroup(From => 'me');\n\n my @from = $rg->From;\n\n my @rgs = $head->resentGroups;\n $rg[2]->delete if @rgs > 2;\n",
               "path" : "SYNOPSIS"
            },
            {
               "description" : "A I<resent group> is a set of header fields which describe one intermediate\nstep in the message transport.  Resent groups B<have NOTHING to do> with\nuser activety; there is no relation to the C<user's> sense of creating\nreply, forward, or bounce messages at all!\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "path" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "level" : 2,
                     "name" : "The header",
                     "type" : "Section",
                     "path" : "METHODS/The header"
                  },
                  {
                     "level" : 2,
                     "name" : "Access to the header",
                     "type" : "Section",
                     "path" : "METHODS/Access to the header"
                  },
                  {
                     "path" : "METHODS/Internals",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Internals"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Error handling"
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "header fields tracking message delivery",
         "name" : "Mail::Message::Head::ResentGroup",
         "package" : "Mail::Message::Head::ResentGroup",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Head/ResentGroup.pm"
      },
      "Mail::Message" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message",
         "chapters" : [
            {
               "name" : "NAME",
               "type" : "Chapter",
               "description" : "Mail::Message - general message object\n",
               "level" : 1,
               "path" : "NAME"
            },
            {
               "level" : 1,
               "description" : " use M<Mail::Box::Manager>;\n my $mgr    = Mail::Box::Manager->new;\n my $folder = $mgr->open(folder => 'InBox');\n my $msg    = $folder->message(2);    # $msg is a Mail::Message now\n\n my $subject = $msg->subject;         # The message's subject\n my @cc      = $msg->cc;              # List of Mail::Address'es\n\n my Mail::Message::Head $head = $msg->head;\n my Mail::Message::Body $body = $msg->decoded;\n $msg->decoded->print($outfile);\n\n # Send a simple email\n Mail::Message->build\n   ( To             => 'you@example.com'\n   , From           => 'me@example.com'\n   , Subject        => \"My subject\"\n   , data           => \"Some plain text content\"\n   )->send(via => 'postfix');\n\n my $reply_msg = Mail::Message->reply(...);\n my $frwd_msg  = Mail::Message->forward(...);\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "A C<Mail::Message> object is a container for MIME-encoded message information,\nas defined by RFC2822.  Everything what is not specificaly related to storing\nthe messages in mailboxes (folders) is implemented in this class.  Methods\nwhich are related to folders is implemented in the M<Mail::Box::Message>\nextension.\n\nThe main methods are M<get()>, to get information from a message header\nfield, and M<decoded()> to get the intended content of a message.\nBut there are many more which can assist your program.\n\nComplex message handling, like construction of replies and forwards, are\nimplemented in separate packages which are autoloaded into this class.\nThis means you can simply use these methods as if they are part of this class.\nThose package add functionality to all kinds of message objects.\n",
               "path" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "type" : "Section",
                     "name" : "Constructors",
                     "level" : 2,
                     "path" : "METHODS/Constructors"
                  },
                  {
                     "path" : "METHODS/Constructing a message",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Constructing a message"
                  },
                  {
                     "path" : "METHODS/The message",
                     "name" : "The message",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "The header",
                     "level" : 2,
                     "path" : "METHODS/The header"
                  },
                  {
                     "path" : "METHODS/The body",
                     "level" : 2,
                     "name" : "The body",
                     "type" : "Section"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Flags",
                     "path" : "METHODS/Flags"
                  },
                  {
                     "path" : "METHODS/The whole message as text",
                     "type" : "Section",
                     "name" : "The whole message as text",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Internals",
                     "name" : "Internals",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "name" : "Error handling",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Cleanup",
                     "level" : 2,
                     "name" : "Cleanup",
                     "type" : "Section"
                  }
               ],
               "path" : "METHODS"
            },
            {
               "path" : "DETAILS",
               "nest" : [
                  {
                     "nest" : [
                        {
                           "level" : 3,
                           "description" : "The header is a list of fields, some spanning more than one line\n(I<folded>) each telling something about the message. Information stored\nin here are for instance the sender of the message, the receivers of\nthe message, when it was transported, how it was transported, etc.\nHeaders can grow quite large.\n\nIn MailBox, each message object manages exactly one header object\n(a M<Mail::Message::Head>) and one body object (a M<Mail::Message::Body>).\nThe header contains a list of header fields, which are represented by\nM<Mail::Message::Field> objects.\n",
                           "type" : "Subsection",
                           "name" : "The header",
                           "path" : "DETAILS/Structure of a Message/The header"
                        },
                        {
                           "type" : "Subsection",
                           "name" : "The body",
                           "level" : 3,
                           "description" : "The body contains the \"payload\": the data to be transferred.\nThe data can be encoded, only accessible with a specific application,\nand may use some weird character-set, like Vietnamese; the MailBox\ndistribution tries to assist you with handling these e-mails without\nthe need to know all the details.  This additional information\n(\"meta-information\") about the body data is stored in the header.\nThe header contains more information, for instance about the message\ntransport and relations to other messages.\n",
                           "path" : "DETAILS/Structure of a Message/The body"
                        }
                     ],
                     "path" : "DETAILS/Structure of a Message",
                     "type" : "Section",
                     "name" : "Structure of a Message",
                     "level" : 2,
                     "description" : "A MIME-compliant message is build upon two parts: the I<header> and the\nI<body>.\n"
                  },
                  {
                     "type" : "Section",
                     "name" : "Message object implementation",
                     "level" : 2,
                     "description" : "The general idea about the structure of a message is\n\n M<Mail::Message>\n  |  |\n  |  `-has-one--M<Mail::Message::Body>\n  |\n  `----has-one--M<Mail::Message::Head>\n                  |\n                  `-has-many--M<Mail::Message::Field>\n\nHowever: there are about 7 kinds of body objects, 3 kinds of headers and\n3 kinds of fields.  You will usually not see too much of these kinds,\nbecause they are merely created for performance reasons and can be used\nall the same, with the exception of the multipart bodies.\n\nA multipart body is either a M<Mail::Message::Body::Multipart>\n(mime type C<multipart/*>) or a M<Mail::Message::Body::Nested>\n(mime type C<message/rfc822>).  These bodies are more complex:\n\n M<Mail::Message::Body::Multipart>\n  |\n  `-has-many--M<Mail::Message::Part>\n               |  |\n               |  `-has-one--M<Mail::Message::Body>\n               |\n               `----has-one--M<Mail::Message::Head>\n\nBefore you try to reconstruct multiparts or nested messages yourself,\nyou can better take a look at M<Mail::Message::Construct::Rebuild>.\n",
                     "path" : "DETAILS/Message object implementation"
                  },
                  {
                     "path" : "DETAILS/Message class implementation",
                     "level" : 2,
                     "description" : "The class structure of messages is very close to that of folders.  For\ninstance, a M<Mail::Box::File::Message> relates to a M<Mail::Box::File>\nfolder.\n\nAs extra level of inheritance, it has a M<Mail::Message>, which\nis a message without location.  And there is a special case of\nmessage: M<Mail::Message::Part> is a message encapsulated in a\nmultipart body.\n\nThe message types are:\n\n M<Mail::Box::Mbox::Message>            M<Mail::Box::POP3::Message>\n |  M<Mail::Box::Dbx::Message>      M<Mail::Box::IMAP4::Message>  |\n |  |                                                    |  |\n M<Mail::Box::File::Message>             M<Mail::Box::Net::Message>\n         |                                      |\n         |       M<Mail::Box::Maildir::Message>    |\n         |       |   M<Mail::Box::MH::Message>     |\n         |       |   |                          |\n         |       M<Mail::Box::Dir::Message>        |\n         |                |                     |\n         `------------.   |   .-----------------'\n                      |   |   |\n                   M<Mail::Box::Message>    M<Mail::Message::Part>\n                          |                     |\n                          |       .-------------'\n                          |       |\n                      M<Mail::Message>\n                          |\n                          |\n                    M<Mail::Reporter> (general base class)\n\nBy far most folder features are implemented in M<Mail::Box>, so\navailable to all folder types.  Sometimes, features which appear\nin only some of the folder types are simulated for folders that miss\nthem, like sub-folder support for MBOX.\n\nTwo strange other message types are defined:\nthe M<Mail::Message::Dummy>, which fills holes in\nM<Mail::Box::Thread::Node> lists, and a M<Mail::Box::Message::Destructed>,\nthis is an on purpose demolished message to reduce memory consumption.\n",
                     "type" : "Section",
                     "name" : "Message class implementation"
                  },
                  {
                     "level" : 2,
                     "description" : "Labels (also named \"Flags\") are used to indicate some special condition on\nthe message, primary targeted on organizational issues: which messages are\nalready read or should be deleted.  There is a very strong user relation\nto labels.\n\nThe main complication is that each folder type has its own way of storing\nlabels.  To give an indication: MBOX folders use C<Status> and C<X-Status>\nheader fields, MH uses a C<.mh-sequences> file, MAILDIR encodes the flags\nin the message's filename, and IMAP has flags as part of the protocol.\n\nBesides, some folder types can store labels with user defined names,\nwhere other lack that feature.  Some folders have case-insensitive\nlabels, other don't. Read all about the specifics in the manual page of\nthe message type you actually have.\n",
                     "type" : "Section",
                     "name" : "Labels",
                     "path" : "DETAILS/Labels",
                     "nest" : [
                        {
                           "type" : "Subsection",
                           "name" : "Predefined labels",
                           "level" : 3,
                           "description" : "To standardize the folder types, MailBox has defined the following labels,\nwhich can be used with the M<label()> and M<labels()> methods on all kinds\nof messages:\n\n\n=over 4\n\n\n=item * deleted\n\nThis message is flagged to be deleted once the folder closes.  Be very\ncareful about the concept of 'delete' in a folder context : it is only a\nflag, and does not involve immediate action!  This means, for instance,\nthat the memory which is used by Perl to store the message is not released\nimmediately (see M<destruct()> if you need to).\n\nThe methods M<delete()>, M<deleted()>, and M<isDeleted()> are only\nshort-cuts for managing the C<delete> label (as of MailBox 2.052).\n\n\n=item * draft\n\nThe user has prepared this message, but is has not been send (yet).  This\nflag is not automatically added to a message by MailBox, and has only\na meaning in user applications.\n\n\n=item * flagged\n\nMessages can be I<flagged> for some purpose, for instance as result of\na search for spam in a folder.  The M<Mail::Box::messages()> method\ncan be used to collect all these flagged messages from the folder.\n\nProbably it is more useful to use an understandable name (like C<spam>)\nfor these selections, however these self-defined labels can not stored\nin all folder types.\n\n\n=item * old\n\nThe message was already in the folder when it was opened the last time,\nso was not recently added to the folder.  This flag will never automatically\nbe set by MailBox, because it would probably conflict with the user's\nidea of what is old.\n\n\n=item * passed\n\nNot often used or kept, this flag indicates that the message was bounced\nor forwarded to someone else.\n\n\n=item * replied\n\nThe user (or application) has sent a message back to the sender of\nthe message, as response of this one.  This flag is automatically\nset if you use M<reply()>, but not with M<forward()> or M<bounce()>.\n\n\n=item * seen\n\nWhen this flag is set, the receiver of the message has consumed the message.\nA mail user agent (MUA) will set this flag when the user has opened the\nmessage once.\n\n\n=back\n",
                           "path" : "DETAILS/Labels/Predefined labels"
                        },
                        {
                           "level" : 3,
                           "description" : "Mbox folders have no special means of storing information about messages\n(except the message separator line), and therefore have to revert to\nadding fields to the message header when something special comes up.\nThis feature is also enabled for POP3, although whether that works\ndepends on the POP server.\n\nAll applications which can handle mbox folders support the C<Status> and\nC<X-Status> field convensions.  The following encoding is used:\n\n Flag   Field       Label\n R      Status   => seen    (Read)\n O      Status   => old     (not recent)\n A      X-Status => replied (Answered)\n F      X-Status => flagged\n\nThere is no special flag for C<deleted>, which most other folders support:\nmessages flagged to be deleted will never be written to a folder file when\nit is closed.\n",
                           "type" : "Subsection",
                           "name" : "Status and X-Status fields",
                           "path" : "DETAILS/Labels/Status and X-Status fields"
                        }
                     ]
                  }
               ],
               "level" : 1,
               "name" : "DETAILS",
               "type" : "Chapter"
            }
         ],
         "title" : "general message object",
         "package" : "Mail::Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message.pm"
      },
      "Mail::Message::Field" : {
         "title" : "one line of a message header",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Field - one line of a message header\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " my $field = Mail::Message::Field->new(From => 'fish@tux.aq');\n print $field->name;\n print $field->body;\n print $field->comment;\n print $field->content;  # body & comment\n $field->print(\\*OUT);\n print $field->string;\n print \"$field\\n\";\n print $field->attribute('charset') || 'us-ascii';\n",
               "level" : 1
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "This implementation follows the guidelines of rfc2822 as close as possible,\nand may there produce a different output than implementations based on\nthe obsolete rfc822.  However, the old output will still be accepted.\n\nThese objects each store one header line, and facilitates access routines to\nthe information hidden in it.  Also, you may want to have a look at the\nadded methods of a message:\n\n my @from    = $message->from;\n my $sender  = $message->sender;\n my $subject = $message->subject;\n my $msgid   = $message->messageId;\n\n my @to      = $message->to;\n my @cc      = $message->cc;\n my @bcc     = $message->bcc;\n my @dest    = $message->destinations;\n\n my $other   = $message->get('Reply-To');\n",
               "level" : 1
            },
            {
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "level" : 2,
                     "name" : "Constructors",
                     "type" : "Section"
                  },
                  {
                     "level" : 2,
                     "name" : "The field",
                     "type" : "Section",
                     "path" : "METHODS/The field"
                  },
                  {
                     "path" : "METHODS/Access to the name",
                     "type" : "Section",
                     "name" : "Access to the name",
                     "level" : 2
                  },
                  {
                     "name" : "Access to the body",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Access to the body"
                  },
                  {
                     "name" : "Access to the content",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Access to the content"
                  },
                  {
                     "name" : "Other methods",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Other methods"
                  },
                  {
                     "path" : "METHODS/Internals",
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Internals"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Error handling",
                     "path" : "METHODS/Error handling"
                  }
               ]
            },
            {
               "level" : 1,
               "name" : "DETAILS",
               "type" : "Chapter",
               "path" : "DETAILS",
               "nest" : [
                  {
                     "nest" : [
                        {
                           "path" : "DETAILS/Field syntax/Folding fields",
                           "level" : 3,
                           "description" : "Fields which are long can be folded to span more than one line.  The real\nlimit for lines in messages is only at 998 characters, however such long\nlines are not easy to read without support of an application.  Therefore\nrfc2822 (which defines the message syntax) specifies explicitly that\nfield lines can be re-formatted into multiple sorter lines without change\nof meaning, by adding new-line characters to any field before any blank or\ntab.\n\nUsually, the lines are reformatted to create lines which are 78 characters\nmaximum. Some applications try harder to fold on nice spots, like before\nattributes.  Especially the C<Received> field is often manually folded into\nsome nice layout.  In most cases however, it is preferred to produce lines\nwhich are as long as possible but max 78.\n\nBE WARNED that all fields can be subjected to folding, and that you usually\nwant the unfolded value.\n",
                           "type" : "Subsection",
                           "name" : "Folding fields"
                        },
                        {
                           "path" : "DETAILS/Field syntax/Structured fields",
                           "level" : 3,
                           "description" : "The rfc2822 describes a large number of header fields explicitly.  These\nfields have a defined meaning.  For some of the fields, like the C<Subject>\nfield, the meaning is straight forward the contents itself.  These fields\nare the I<Unstructured Fields>.\n\nOther fields have a well defined internal syntax because their content is\nneeded by e-mail applications. For instance, the C<To> field contains\naddresses which must be understood by all applications in the same way.\nThese are the I<Structured Fields>, see M<isStructured()>.\n",
                           "type" : "Subsection",
                           "name" : "Structured fields"
                        },
                        {
                           "path" : "DETAILS/Field syntax/Comments in fields",
                           "type" : "Subsection",
                           "name" : "Comments in fields",
                           "level" : 3,
                           "description" : "Stuctured fields can contain comments, which are pieces of text enclosed in\nparenthesis.  These comments can be placed close to anywhere in the line\nand must be ignored be the application.  Not all applications are capable\nof handling comments correctly in all circumstances.\n"
                        }
                     ],
                     "path" : "DETAILS/Field syntax",
                     "type" : "Section",
                     "name" : "Field syntax",
                     "level" : 2,
                     "description" : "Fields are stored in the header of a message, which are represented by\nM<Mail::Message::Head> objects. A field is a combination of a I<name>,\nI<body>, and I<attributes>.  Especially the term \"body\" is cause for\nconfusion: sometimes the attributes are considered to be part of the body.\n\nThe name of the field is followed by a colon (\"C<:>\", not preceded by\nblanks, but followed by one blank).  Each attribute is preceded by\na separate semi-colon (\"C<;>\").  Names of fields are case-insensitive and\ncannot contain blanks.\n"
                  },
                  {
                     "nest" : [
                        {
                           "name" : "Using get() field",
                           "type" : "Subsection",
                           "description" : "The C<get()> interface is copied from other Perl modules which can\nhandle e-mail messages.  Many applications which simply replace\nM<Mail::Internet> objects by M<Mail::Message> objects will work\nwithout modification.\n\nThere is more than one get method.  The exact results depend on which\nget you use.  When M<Mail::Message::get()> is called, you will get the\nunfolded, stripped from comments, stripped from attributes contents of\nthe field as B<string>.  Character-set encodings will still be in the\nstring.  If the same fieldname appears more than once in the header,\nonly the last value is returned.\n\nWhen M<Mail::Message::Head::get()> is called in scalar context, the\nlast field with the specified name is returned as field B<object>.\nThis object strinigfies into the unfolded contents of the field, including\nattributes and comments.  In list context, all appearances of the field\nin the header are returned as objects.\n\nBE WARNED that some lines seem unique, but are not according to the\nofficial rfc.  For instance, C<To> fields can appear more than once.\nIf your program calls C<get('to')> in scalar context, some information\nis lost.\n",
                           "level" : 3,
                           "path" : "DETAILS/Getting a field/Using get() field"
                        },
                        {
                           "name" : "Using study() field",
                           "type" : "Subsection",
                           "description" : "As the name C<study> already implies, this way of accessing the fields is\nmuch more thorough but also slower.  The C<study> of a field is like a\nC<get>, but provides easy access to the content of the field and handles\ncharacter-set decoding correctly.\n\nThe M<Mail::Message::study()> method will only return the last field\nwith that name as object.  M<Mail::Message::Head::study()> and\nM<Mail::Message::Field::study()> return all fields when used in list\ncontext.\n",
                           "level" : 3,
                           "path" : "DETAILS/Getting a field/Using study() field"
                        },
                        {
                           "path" : "DETAILS/Getting a field/Using resent groups",
                           "level" : 3,
                           "description" : "Some fields belong together in a group of fields.  For instance, a set\nof lines is used to define one step in the mail transport process.  Each\nstep adds a C<Received> line, and optionally some C<Resent-*> lines and\nC<Return-Path>.  These groups of lines shall stay together and in order\nwhen the message header is processed.\n\nThe C<Mail::Message::Head::ResentGroup> object simplifies the access to\nthese related fields.  These resent groups can be deleted as a whole,\nor correctly constructed.\n",
                           "type" : "Subsection",
                           "name" : "Using resent groups"
                        }
                     ],
                     "path" : "DETAILS/Getting a field",
                     "type" : "Section",
                     "name" : "Getting a field",
                     "level" : 2,
                     "description" : "As many programs as there are handling e-mail, as many variations on\naccessing the header information are requested.  Be careful which way\nyou access the data: read the variations described here and decide\nwhich solution suites your needs best.\n"
                  },
                  {
                     "name" : "The field's data",
                     "type" : "Section",
                     "description" : "There are many ways to get the fields info as object, and there are also\nmany ways to process this data within the field.\n",
                     "level" : 2,
                     "nest" : [
                        {
                           "level" : 3,
                           "description" : "=over 4\n\n\n=item * M<string()>\n\nReturns the text of the body exactly as will be printed to file when\nM<print()> is called, so name, main body, and attributes.\n\n\n=item * M<foldedBody()>\n\nReturns the text of the body, like M<string()>, but without the name of\nthe field.\n\n\n=item * M<unfoldedBody()>\n\nReturns the text of the body, like M<foldedBody()>, but then with all\nnew-lines removed.  This is the normal way to get the content of\nunstructured fields.  Character-set encodings will still be in place.\nFields are stringified into their unfolded representation.\n\n\n=item * M<stripCFWS()>\n\nReturns the text of structured fields, where new-lines and comments are\nremoved from the string.  This is a good start for parsing the field,\nfor instance to find e-mail addresses in them.\n\n\n=item * M<Mail::Message::Field::Full::decodedBody()>\n\nStudied fields can produce the unfolded text decoded into utf8 strings.\nThis is an expensive process, but the only correct way to get the field's\ndata.  More useful for people who are not living in ASCII space.\n\n\n=item * Studied fields\n\nStudied fields have powerful methods to provide ways to access and produce\nthe contents of (structured) fields exactly as the involved rfcs prescribe.\n\n\n=back\n",
                           "type" : "Subsection",
                           "name" : "Access to the field",
                           "path" : "DETAILS/The field's data/Access to the field"
                        },
                        {
                           "name" : "Using simplified field access",
                           "type" : "Subsection",
                           "description" : "Some fields are accessed that often that there are support methods to\nprovide simplified access.  All these methods are called upon a message\ndirectly.\n",
                           "level" : 3,
                           "path" : "DETAILS/The field's data/Using simplified field access"
                        },
                        {
                           "name" : "Specifying field data",
                           "type" : "Subsection",
                           "description" : "Field data can be anything, strongly dependent on the type\nof field at hand. If you decide to construct the fields very\ncarefully via some M<Mail::Message::Field::Full> extension (like via\nM<Mail::Message::Field::Addresses> objects), then you will have protection\nbuild-in.  However, you can bluntly create any M<Mail::Message::Field>\nobject based on some data.\n\nWhen you create a field, you may specify a string, object, or an array\nof strings and objects.  On the moment, objects are only used to help\nthe construction on e-mail addresses, however you may add some of your\nown.\n\nThe following rules (implemented in M<stringifyData()>) are obeyed given\nthe argument is:\n\n\n=over 4\n\n=item * a string\nThe string must be following the (complicated) rules of the rfc2822, and\nis made field content as specified.  When the string is not terminated\nby a new-line (C<\"\\n\">) it will be folded according to the standard rules.\n\n\n=item * a M<Mail::Address> object\nThe most used Perl object to parse and produce address lines.  This object\ndoes not understand character set encodings in phrases.\n\n\n=item * a M<Mail::Identity> object\nAs part of the M<User::Identity> distribution, this object has full\nunderstanding of the meaning of one e-mail address, related to a person.\nAll features defined by rfc2822 are implemented.\n\n\n=item * a M<User::Identity> object\nA person is specified, which may have more than one M<Mail::Identity>'s\ndefined.  Some methods, like M<Mail::Message::reply()> and\nM<Mail::Message::forward()> try to select the right e-mail address\nsmart (see their method descriptions), but in other cases the first\ne-mail address found is used.\n\n\n=item * a M<User::Identity::Collection::Emails> object\nAll M<Mail::Identity> objects in the collection will be included in\nthe field as a group carying the name of the collection.\n\n\n=item * any other object\nFor all other objects, the stringification overload is used to produce\nthe field content.\n\n\n=item * an ARRAY\nYou may also specify an array with a mixture of any of the above.  The\nelements will be joined as comma-separated list.  If you do not want\ncomma's inbetween, you will have to process the array yourself.\n\n\n=back\n",
                           "level" : 3,
                           "path" : "DETAILS/The field's data/Specifying field data"
                        }
                     ],
                     "path" : "DETAILS/The field's data"
                  },
                  {
                     "level" : 2,
                     "description" : "For performance reasons only, there are three types of fields: the\nfast, the flexible, and the full understander:\n\n\n=over 4\n\n\n=item * M<Mail::Message::Field::Fast>\n\nC<Fast> objects are not derived from a C<Mail::Reporter>.  The consideration\nis that fields are so often created, and such a small objects at the same\ntime, that setting-up a logging for each of the objects is relatively\nexpensive and not really useful.\nThe fast field implementation uses an array to store the data: that\nwill be faster than using a hash.  Fast fields are not easily inheritable,\nbecause the object creation and initiation is merged into one method.\n\n\n=item * M<Mail::Message::Field::Flex>\n\nThe flexible implementation uses a hash to store the data.  The M<new()>\nand C<init> methods are split, so this object is extensible.\n\n\n=item * M<Mail::Message::Field::Full>\n\nWith a full implementation of all applicable RFCs (about 5), the best\nunderstanding of the fields is reached.  However, this comes with\na serious memory and performance penalty.  These objects are created\nfrom fast or flex header fields when M<study()> is called.\n\n\n=back\n",
                     "type" : "Section",
                     "name" : "Field class implementation",
                     "path" : "DETAILS/Field class implementation"
                  }
               ]
            }
         ],
         "name" : "Mail::Message::Field",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field.pm",
         "package" : "Mail::Message::Field"
      },
      "Mail::Message::Construct::Bounce" : {
         "name" : "Mail::Message::Construct::Bounce",
         "title" : "bounce a Mail::Message",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Construct::Bounce - bounce a Mail::Message\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "level" : 1,
               "description" : " $message->bounce(To => 'you')->send;\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Complex functionality on M<Mail::Message> objects is implemented in\ndifferent files which are autoloaded.  This file implements the\nfunctionality related to bouncing messages off to other destinations.\n\nB<Be warned:> bouncing messages was very common practice in the past,\nbut does not play well together with SPF spam protection.  Unless you\nbounce messages which originate from inside your own infrastructure,\nyou may get the message rejected by the spam-filters of the receivers.\nThe way around it, is to implement ARC... which the MailBox suite did\nnot try (yet).\n"
            },
            {
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructing a message",
                     "level" : 2,
                     "name" : "Constructing a message",
                     "type" : "Section"
                  }
               ]
            }
         ],
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "version" : "3.018",
         "source" : "lib/Mail/Message/Construct/Bounce.pm",
         "package" : "Mail::Message"
      },
      "Mail::Message::Head::Partial" : {
         "package" : "Mail::Message::Head::Partial",
         "source" : "lib/Mail/Message/Head/Partial.pm",
         "version" : "3.018",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Head::Partial - subset of header information of a message\n",
               "path" : "NAME"
            },
            {
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my $partial = $head->strip;\n $partial->isa('M<Mail::Message::Head>')  # true\n $partial->isDelayed                      # false\n $partial->isPartial                      # true\n\n $partial->removeFields( qr/^X-/ );\n $partial->removeFieldsExcept( qw/To From/ );\n $partial->removeResentGroups;\n $partial->removeListGroup;\n $partial->removeSpamGroups;\n",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "Header information consumes a considerable amount of memory.  Most of this\ninformation is only useful during a short period of time in your program,\nor sometimes it is not used at all.  You then can decide to remove most\nof the header information.  However, be warned that it will be lost\npermanently: the header (and therefore the message) gets mutulated!\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Access to the header",
                     "level" : 2,
                     "name" : "Access to the header",
                     "type" : "Section"
                  }
               ],
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter"
            },
            {
               "type" : "Chapter",
               "name" : "DETAILS",
               "level" : 1,
               "nest" : [
                  {
                     "type" : "Section",
                     "name" : "Reducing the header size",
                     "level" : 2,
                     "description" : "A message header is very large in memory and quite large on disk, and\ntherefore a good candidate for size reduction.  One way to reduce the\nsize is by simply eliminating superfluous header fields.  Each field\nrequires at least 100 bytes of run-time memory, so this may help!\n\nBefore you start playing around with M<removeFields()> and\nM<removeFieldsExcept()>, you may take a look at two large groups\nof fields which can be removes as sets: the resent headers and the\nmailinglist headers.\n\nResent headers describe the intermediate steps in the transmission\nprocess for the messages.  After successful delivery, they are rarely\nuseful.\n\nWhen you are archiving a mailinglist, it is hardly ever useful to\nstore a the list administration lines for each message as well.\n",
                     "path" : "DETAILS/Reducing the header size"
                  }
               ],
               "path" : "DETAILS"
            }
         ],
         "title" : "subset of header information of a message",
         "name" : "Mail::Message::Head::Partial"
      },
      "Mail::Message::TransferEnc::QuotedPrint" : {
         "package" : "Mail::Message::TransferEnc::QuotedPrint",
         "version" : "3.018",
         "source" : "lib/Mail/Message/TransferEnc/QuotedPrint.pm",
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::TransferEnc::QuotedPrint",
         "title" : "handle quoted-printable message bodies",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::TransferEnc::QuotedPrint - handle quoted-printable message bodies\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(transfer => 'quoted-printable');\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "Encode and decode message bodies for quoted-printable transfer encoding.\nThe Quoted-Printable encoding is intended\nto represent data that largely consists of bytes that correspond to\nprintable characters in the ASCII character set.  Non-printable\ncharacters (as defined by English Americans) are represented by a\ntriplet consisting of the character \"=\" followed by two hexadecimal\ndigits.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter"
            }
         ]
      },
      "Mail::Message::Replace::MailHeader" : {
         "title" : "fake Mail::Header",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Replace::MailHeader - fake Mail::Header\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " !!! ALPHA CODE !!!\n\n # change\n use Mail::Internet;\n use Mail::Header;\n # into\n use Mail::Message::Replace::MailInternet;\n # in existing code, and the code should still work, but\n # with the Mail::Message features.\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "This module is a wrapper around a M<Mail::Message::Head::Complete>,\nwhich simulates a L<Mail::Header> object.  The name-space of that module\nis hijacked and many methods are added.\n\nMost methods will work without any change, but you should test your\nsoftware again.  Small changes have been made to M<fold_length()>,\nM<header_hashref()>.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Access to the header",
                     "type" : "Section",
                     "name" : "Access to the header",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "Access to the header",
                     "level" : 2,
                     "path" : "METHODS/Access to the header"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Simulating Mail::Header",
                     "path" : "METHODS/Simulating Mail::Header"
                  },
                  {
                     "path" : "METHODS/The nasty bits",
                     "name" : "The nasty bits",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "level" : 1,
               "type" : "Chapter",
               "name" : "METHODS"
            }
         ],
         "name" : "Mail::Message::Replace::MailHeader",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Replace/MailHeader.pm",
         "package" : "Mail::Message::Replace::MailHeader"
      },
      "Mail::Message::Body::File" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Body::File",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Body::File - body of a message temporarily stored in a file\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " See M<Mail::Message::Body>\n"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "The body (content) of a message can be stored in various ways.  In this\ndocumentation you find the description of extra functionality you have\nwhen a message is stored in a file.\n\nStoring a whole message is a file is useful when the body is large.  Although\naccess through a file is slower, it is saving a lot of memory.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "nest" : [
                  {
                     "name" : "Internals",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Internals"
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "name" : "Error handling",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "Cleanup",
                     "level" : 2,
                     "path" : "METHODS/Cleanup"
                  }
               ],
               "path" : "METHODS",
               "type" : "Chapter",
               "name" : "METHODS",
               "level" : 1
            }
         ],
         "title" : "body of a message temporarily stored in a file",
         "package" : "Mail::Message::Body::File",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Body/File.pm"
      },
      "Mail::Message::Part" : {
         "package" : "Mail::Message::Part",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Part.pm",
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "title" : "a part of a message, but a message by itself",
         "chapters" : [
            {
               "description" : "Mail::Message::Part - a part of a message, but a message by itself\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "description" : " my Mail::Message $message = ...;\n if($message->isMultipart) {\n    my Mail::Message::Part $part;\n\n    foreach $part ($message->body->parts) {\n       $part->print(\\*OUT);\n       my $attached_head = $part->head;\n       my $attached_body = $part->body;      # encoded as read\n       my $attached_body = $part->decoded;   # transfer-encoding removed\n    }\n }\n",
               "level" : 1,
               "name" : "SYNOPSIS",
               "type" : "Chapter"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "A C<Mail::Message::Part> object contains a message which is included in\nthe body of another message.  For instance I<attachments> are I<parts>.\n\nREAD M<Mail::Message> FIRST.  A part is a special message: it has a\nreference to its parent message, and will usually not be sub-classed\ninto mail folder specific variants.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter",
               "path" : "METHODS",
               "nest" : [
                  {
                     "name" : "The message",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/The message"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "Cleanup",
                     "path" : "METHODS/Cleanup"
                  }
               ]
            }
         ],
         "name" : "Mail::Message::Part"
      },
      "Mail::Message::TransferEnc::SevenBit" : {
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::TransferEnc::SevenBit - encode/decode 7bit message bodies\n",
               "path" : "NAME"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(transfer => '7bit');\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "level" : 1,
               "description" : "Encode or decode message bodies for 7bit transfer encoding.  This is\nonly very little encoding.  According to the specs:\n\nRFC-2045 Section 2.7 defines legal `7bit' data:\n\n  \"7bit data\" refers to data that is all represented as relatively\n  short lines with 998 octets or less between CRLF line separation\n  sequences [RFC-821].  No octets with decimal values greater than 127\n  are allowed and neither are NULs (octets with decimal value 0).  CR\n  (decimal value 13) and LF (decimal value 10) octets only occur as\n  part of CRLF line separation sequences.\n\nAs you can safely conclude: decoding of these bodies is no work\nat all.\n",
               "type" : "Chapter",
               "name" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "path" : "METHODS"
            }
         ],
         "title" : "encode/decode 7bit message bodies",
         "name" : "Mail::Message::TransferEnc::SevenBit",
         "package" : "Mail::Message::TransferEnc::SevenBit",
         "version" : "3.018",
         "source" : "lib/Mail/Message/TransferEnc/SevenBit.pm"
      },
      "Mail::Message::TransferEnc::EightBit" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::TransferEnc::EightBit",
         "title" : "encode/decode 8bit message bodies",
         "chapters" : [
            {
               "path" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::TransferEnc::EightBit - encode/decode 8bit message bodies\n",
               "type" : "Chapter",
               "name" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "level" : 1,
               "description" : " my Mail::Message $msg = ...;\n my $decoded = $msg->decoded;\n my $encoded = $msg->encode(transfer => '8bit');\n"
            },
            {
               "type" : "Chapter",
               "name" : "DESCRIPTION",
               "level" : 1,
               "description" : "Encode or decode message bodies for 8bit transfer encoding.  This is\nonly very little encoding.  According to the specs:\n\nRFC-2045 Section 2.8 defines legal `8bit' data:\n\n \"8bit data\" refers to data that is all represented as relatively\n short lines with 998 octets or less between CRLF line separation\n sequences [RFC-821]), but octets with decimal values greater than 127\n may be used.  As with \"7bit data\" CR and LF octets only occur as part\n of CRLF line separation sequences and no NULs are allowed.\n\nAs you can safely conclude: decoding of these bodies is no work\nat all.\n",
               "path" : "DESCRIPTION"
            },
            {
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "package" : "Mail::Message::TransferEnc::EightBit",
         "source" : "lib/Mail/Message/TransferEnc/EightBit.pm",
         "version" : "3.018"
      },
      "Mail::Message::Replace::MailInternet" : {
         "distribution" : "Mail-Message",
         "is_pure_pod" : 0,
         "name" : "Mail::Message::Replace::MailInternet",
         "title" : "fake Mail::Internet",
         "chapters" : [
            {
               "level" : 1,
               "description" : "Mail::Message::Replace::MailInternet - fake Mail::Internet\n",
               "type" : "Chapter",
               "name" : "NAME",
               "path" : "NAME"
            },
            {
               "path" : "SYNOPSIS",
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " # change\n use Mail::Internet;\n # into\n use Mail::Message::Replace::MailInternet;\n # in existing code, and the code should still work, but\n # with the Mail::Message features.\n",
               "level" : 1
            },
            {
               "path" : "DESCRIPTION",
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "This module is a wrapper around a M<Mail::Message>, which simulates\na L<Mail::Internet> object.  The name-space of that module is hijacked\nand many methods are added.\n\nMost methods will work without any change, but you may need to have\na look at your M<smtpsend()> and M<send()> calls.\n",
               "level" : 1
            },
            {
               "level" : 1,
               "name" : "METHODS",
               "type" : "Chapter",
               "path" : "METHODS",
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "type" : "Section",
                     "name" : "Constructors",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Attributes",
                     "type" : "Section",
                     "name" : "Attributes",
                     "level" : 2
                  },
                  {
                     "type" : "Section",
                     "name" : "Constructing a message",
                     "level" : 2,
                     "path" : "METHODS/Constructing a message"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "The message",
                     "path" : "METHODS/The message"
                  },
                  {
                     "name" : "The header",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/The header"
                  },
                  {
                     "level" : 2,
                     "name" : "The body",
                     "type" : "Section",
                     "path" : "METHODS/The body"
                  },
                  {
                     "level" : 2,
                     "type" : "Section",
                     "name" : "The whole message as text",
                     "path" : "METHODS/The whole message as text"
                  },
                  {
                     "name" : "The nasty bits",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/The nasty bits"
                  },
                  {
                     "name" : "Internals",
                     "type" : "Section",
                     "level" : 2,
                     "path" : "METHODS/Internals"
                  }
               ]
            }
         ],
         "package" : "Mail::Message::Replace::MailInternet",
         "source" : "lib/Mail/Message/Replace/MailInternet.pm",
         "version" : "3.018"
      },
      "Mail::Message::Field::DKIM" : {
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "chapters" : [
            {
               "path" : "NAME",
               "description" : "Mail::Message::Field::DKIM - message header field for dkim signatures\n",
               "level" : 1,
               "name" : "NAME",
               "type" : "Chapter"
            },
            {
               "name" : "SYNOPSIS",
               "type" : "Chapter",
               "description" : " my $f = Mail::Message::Field->new('DKIM-Signature' => '...');\n\n my $g = Mail::Message::Field->new('DKIM-Signature');\n $g->add...\n",
               "level" : 1,
               "path" : "SYNOPSIS"
            },
            {
               "name" : "DESCRIPTION",
               "type" : "Chapter",
               "description" : "Decode the information contained in a DKIM header.  You can also\nconstruct DKIM-Signature headers this way.  However, verification\nand signing is not yet implemented.\n\nThis implementation is based on RFC6376.\n",
               "level" : 1,
               "path" : "DESCRIPTION"
            },
            {
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1,
               "nest" : [
                  {
                     "path" : "METHODS/Constructors",
                     "name" : "Constructors",
                     "type" : "Section",
                     "level" : 2
                  },
                  {
                     "nest" : [
                        {
                           "level" : 3,
                           "description" : "The tag methods return the tag-value content without any validation\nor modification.  For many situations, the actual content does not\nneed (expensive) validation and interpretation.\n",
                           "type" : "Subsection",
                           "name" : "DKIM-Signature tags",
                           "path" : "METHODS/Access to the content/DKIM-Signature tags"
                        }
                     ],
                     "path" : "METHODS/Access to the content",
                     "type" : "Section",
                     "name" : "Access to the content",
                     "level" : 2
                  },
                  {
                     "path" : "METHODS/Error handling",
                     "type" : "Section",
                     "name" : "Error handling",
                     "level" : 2
                  }
               ],
               "path" : "METHODS"
            }
         ],
         "title" : "message header field for dkim signatures",
         "name" : "Mail::Message::Field::DKIM",
         "package" : "Mail::Message::Field::DKIM",
         "version" : "3.018",
         "source" : "lib/Mail/Message/Field/DKIM.pm"
      },
      "Mail::Message::Convert::Html" : {
         "is_pure_pod" : 0,
         "distribution" : "Mail-Message",
         "title" : "Format messages in HTML",
         "chapters" : [
            {
               "type" : "Chapter",
               "name" : "NAME",
               "level" : 1,
               "description" : "Mail::Message::Convert::Html - Format messages in HTML\n",
               "path" : "NAME"
            },
            {
               "level" : 1,
               "description" : " use Mail::Message::Convert::Html;\n my $Html = Mail::Message::Convert::Html->new;\n\n print $html->fieldToHtml($head);\n print $html->headToHtmlHead($head);\n print $html->headToHtmlTable($head);\n print $html->textToHtml($text);\n",
               "type" : "Chapter",
               "name" : "SYNOPSIS",
               "path" : "SYNOPSIS"
            },
            {
               "path" : "DESCRIPTION",
               "description" : "The package contains various translators which handle HTML or XHTML\nwithout the help of external modules.  There are more HTML related modules,\nwhich do require extra packages to be installed.\n",
               "level" : 1,
               "name" : "DESCRIPTION",
               "type" : "Chapter"
            },
            {
               "nest" : [
                  {
                     "path" : "METHODS/Converting",
                     "name" : "Converting",
                     "type" : "Section",
                     "level" : 2
                  }
               ],
               "path" : "METHODS",
               "name" : "METHODS",
               "type" : "Chapter",
               "level" : 1
            }
         ],
         "name" : "Mail::Message::Convert::Html",
         "package" : "Mail::Message::Convert::Html",
         "source" : "lib/Mail/Message/Convert/Html.pm",
         "version" : "3.018"
      }
   },
   "version" : "3.018"
}
